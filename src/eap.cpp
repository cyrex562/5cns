/*
 * eap.c - Extensible Authentication Protocol for PPP (RFC 2284)
 *
 * Copyright (c) 2001 by Sun Microsystems, Inc.
 * All rights reserved.
 *
 * Non-exclusive rights to redistribute, modify, translate, and use
 * this software in source and binary forms, in whole or in part, is
 * hereby granted, provided that the above copyright notice is
 * duplicated in any source form, and that neither the name of the
 * copyright holder nor the author is used to endorse or promote
 * products derived from this software.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Original version by James Carlson
 *
 * This implementation of EAP supports MD5-Challenge and SRP-SHA1
 * authentication styles.  Note that support of MD5-Challenge is a
 * requirement of RFC 2284, and that it's essentially just a
 * reimplementation of regular RFC 1994 CHAP using EAP messages.
 *
 * As an authenticator ("server"), there are multiple phases for each
 * style.  In the first phase of each style, the unauthenticated peer
 * name is queried using the EAP Identity request type.  If the
 * "remotename" option is used, then this phase is skipped, because
 * the peer's name is presumed to be known.
 *
 * For MD5-Challenge, there are two phases, and the second phase
 * consists of sending the challenge itself and handling the
 * associated response.
 *
 * For SRP-SHA1, there are four phases.  The second sends 's', 'N',
 * and 'g'.  The reply contains 'A'.  The third sends 'B', and the
 * reply contains 'M1'.  The forth sends the 'M2' value.
 *
 * As an authenticatee ("client"), there's just a single phase --
 * responding to the queries generated by the peer.  EAP is an
 * authenticator-driven protocol.
 *
 * Based on draft-ietf-pppext-eap-srp-03.txt.
 */

#define NOMINMAX
#include <eap.h>
#include <eap_state.h>
#include <auth.h>
#include <magic.h>

#include <ppp_opts.h>
#include <pppcrypt.h>
#include <ppp.h>
#include <ctime>
#include "util.h"


/*
 * Protocol entry points.
 */
static void eap_init(PppPcb *pcb, EapState* eap);
static void eap_input(PppPcb *pcb, char* inp, size_t inlen);
static void eap_protrej(PppPcb *pcb);
static void eap_lowerup(PppPcb *pcb);
static void eap_lowerdown(PppPcb *pcb);
// #if PRINTPKT_SUPPORT
// static int eap_printpkt(const uint8_t *inp, int inlen,
//                         void (*)(uint8_t *arg, const char *fmt, ...), uint8_t *arg);
// #endif /* PRINTPKT_SUPPORT */
// const Protent eap_protent = {
//     PPP_EAP,
//     /* protocol number */
//     eap_init,
//     /* initialization procedure */
//     eap_input,
//     /* process a received packet */
//     eap_protrej,
//     /* process a received protocol-reject */
//     eap_lowerup,
//     /* lower layer has gone up */
//     eap_lowerdown,
//     /* lower layer has gone down */
//     NULL,
//     /* open the protocol */
//     NULL,
//     /* close the protocol */
//     NULL,
//     /* process a received data packet */
// };

// #ifdef USE_SRP
// /*
//  * A well-known 2048 bit modulus.
//  */
//
// #endif

/* Local forward declarations. */
static void eap_server_timeout(void* arg);


inline bool
eap_client_active(PppPcb& ppp_pcb)
{
    return (ppp_pcb.eap.es_client.ea_state == kEapListen);
}

/*
 * Convert EAP state code to printable string for debug.
 */
static const char *eap_state_name(enum EapStateCode esc) {
  static const char *state_names[] = {"Initial", "Pending", "Closed", "Listen", "Identify", "SRP1", "SRP2", "SRP3", "MD5Chall", "Open", "SRP4", "BadAuth"};

  return (state_names[(int)esc]);
}

/*
 * eap_init - Initialize state for an EAP user.  This is currently
 * called once by main() during start-up.
 */
static void eap_init(PppPcb* pcb, EapState* eap)
{
    zero_mem(eap, sizeof(EapState));
    eap->es_server.ea_id = magic();
}

/*
 * eap_client_timeout - Give up waiting for the peer to send any
 * Request messages.
 */
bool
eap_client_timeout(PppPcb& pcb)
{
    // auto pcb = reinterpret_cast<PppPcb *>(pcb);
    if (!eap_client_active(pcb))
    {
        return false;
    }
    ppp_error("EAP: timeout waiting for Request from peer");
    auth_withpeer_fail(pcb, PPP_EAP);
    pcb.eap.es_client.ea_state = eapBadAuth;
    return true;
}

//
// Authenticate to peer as a client
// Start the client and wait for requests
// Called after eap_lowerup
//
bool
eap_authwithpeer(PppPcb& pcb)
{
    const auto localname = pcb.settings.user;
    auto eap = &pcb.eap;
    eap->es_client.ea_name = localname;
    eap->es_client.ea_state = kEapListen; //
    // Start a timer so that if the other end just goes
    // silent, we don't sit here waiting forever.
    //
    if (pcb.settings.eap_req_time > 0) {
        if (!eap_client_timeout(pcb)) {
            return false;
        }
    }
    return true;
}

/*
 * Format a standard EAP Failure message and send it to the peer.
 * (Server operation)
 */
static void eap_send_failure(PppPcb& pcb)
{
    struct PacketBuffer* p = new PacketBuffer;

    // p = pbuf_alloc(PBUF_RAW, (uint16_t)(PPP_HDRLEN + EAP_HEADERLEN),
    //                PPP_CTRL_PBUF_TYPE);
    if (nullptr == p) return;
    if (p->tot_len != p->len)
    {
        free_pkt_buf(p);
        return;
    }

    uint8_t* outp = static_cast<uint8_t *>(p->payload);

    // MAKEHEADER(outp, PPP_EAP);
    PUTCHAR(PPP_ALLSTATIONS, outp); \
    PUTCHAR(PPP_UI, outp); \
    PUTSHORT(PPP_EAP, outp);

    PUTCHAR(EAP_FAILURE, outp);
    pcb->eap.es_server.ea_id++;
    PUTCHAR(pcb->eap.es_server.ea_id, outp);
    PUTSHORT(EAP_HEADERLEN, outp);

    ppp_write(pcb, p);

    pcb->eap.es_server.ea_state = eapBadAuth;
    auth_peer_fail(pcb, PPP_EAP);
}

/*
 * Format a standard EAP Success message and send it to the peer.
 * (Server operation)
 */
static void eap_send_success(PppPcb* pcb)
{
    // p = pbuf_alloc(PBUF_RAW, (uint16_t)(PPP_HDRLEN + EAP_HEADERLEN),
    //                PPP_CTRL_PBUF_TYPE);
    struct PacketBuffer* p = new PacketBuffer;
    if (nullptr == p)
    {
        return;
    }
    if (p->tot_len != p->len)
    {
        free_pkt_buf(p);
        return;
    }

    auto outp = static_cast<uint8_t *>(p->payload);

    // MAKEHEADER(outp, PPP_EAP);
    PUTCHAR(PPP_ALLSTATIONS, outp);
    PUTCHAR(PPP_UI, outp);
    PUTSHORT(PPP_EAP, outp);

    PUTCHAR(EAP_SUCCESS, outp);
    pcb->eap.es_server.ea_id++;
    PUTCHAR(pcb->eap.es_server.ea_id, outp);
    PUTSHORT(EAP_HEADERLEN, outp);

    ppp_write(pcb, p);

    auth_peer_success(pcb, PPP_EAP, 0, pcb->eap.es_server.ea_peer);
}

/*
 * Set DES key according to pseudonym-generating secret and current
 * date.
 */
static bool pncrypt_setkey(int timeoffs)
{
    struct tm* tp;
    char tbuf[9];
    Sha1Context ctxt;
    uint8_t dig[SHA_DIGESTSIZE];
    time_t reftime;
    // TODO: reimplement
    //
    // if (pn_secret == NULL) return (0);
    // reftime = time(NULL) + timeoffs;
    // tp = localtime(&reftime);
    // SHA1Init(&ctxt);
    // SHA1Update(&ctxt, pn_secret, strlen(pn_secret));
    // strftime(tbuf, sizeof(tbuf), "%Y%m%d", tp);
    // SHA1Update(&ctxt, tbuf, strlen(tbuf));
    // SHA1Final(dig, &ctxt);
    // /* FIXME: if we want to do SRP, we need to find a way to pass the PolarSSL
    //  * des_context instead of using static memory */
    // return (DesSetkey(dig));
    return false;
}


// static int Base64Encode(bs, inp, inlen, outp) struct Base64State *bs;
// uint8_t *inp;
// int inlen;
// uint8_t *outp;
// {
//   int outlen = 0;
//
//   while (inlen > 0) {
//     bs->bs_bits = (bs->bs_bits << 8) | *inp++;
//     inlen--;
//     bs->bs_offs += 8;
//     if (bs->bs_offs >= 24) {
//       *outp++ = base64[(bs->bs_bits >> 18) & 0x3F];
//       *outp++ = base64[(bs->bs_bits >> 12) & 0x3F];
//       *outp++ = base64[(bs->bs_bits >> 6) & 0x3F];
//       *outp++ = base64[bs->bs_bits & 0x3F];
//       outlen += 4;
//       bs->bs_offs = 0;
//       bs->bs_bits = 0;
//     }
//   }
//   return (outlen);
// }

// static int b64flush(bs, outp) struct Base64State *bs;
// uint8_t *outp;
// {
//   int outlen = 0;
//
//   if (bs->bs_offs == 8) {
//     *outp++ = base64[(bs->bs_bits >> 2) & 0x3F];
//     *outp++ = base64[(bs->bs_bits << 4) & 0x3F];
//     outlen = 2;
//   } else if (bs->bs_offs == 16) {
//     *outp++ = base64[(bs->bs_bits >> 10) & 0x3F];
//     *outp++ = base64[(bs->bs_bits >> 4) & 0x3F];
//     *outp++ = base64[(bs->bs_bits << 2) & 0x3F];
//     outlen = 3;
//   }
//   bs->bs_offs = 0;
//   bs->bs_bits = 0;
//   return (outlen);
// }

// static int b64dec(bs, inp, inlen, outp) struct Base64State *bs;
// uint8_t *inp;
// int inlen;
// uint8_t *outp;
// {
//   int outlen = 0;
//   char *cp;
//
//   while (inlen > 0) {
//     if ((cp = strchr(base64, *inp++)) == nullptr) break;
//     bs->bs_bits = (bs->bs_bits << 6) | (cp - base64);
//     inlen--;
//     bs->bs_offs += 6;
//     if (bs->bs_offs >= 8) {
//       *outp++ = bs->bs_bits >> (bs->bs_offs - 8);
//       outlen++;
//       bs->bs_offs -= 8;
//     }
//   }
//   return (outlen);
// }

/*
 * Assume that current waiting server state is complete and figure
 * next state to use based on available authentication data.  'status'
 * indicates if there was an error in handling the last query.  It is
 * 0 for success and non-zero for failure.
 */
static void eap_figure_next_state(PppPcb& pcb, const int status)
{
    unsigned char secbuf[MAXSECRETLEN], clear[8];
    char *cp; // struct t_pw tpw;
    char *cp2; // struct t_confent *tce, mytce;
    struct t_server* ts;
    int i;
    int plen;
    struct Base64State bs{};

    pcb.settings.eap_timeout_time = pcb.eap.es_savedtime;
    switch (pcb.eap.es_server.ea_state)
    {
    case eapBadAuth:
        return;

    case eapIdentify:

        /* Discard any previous session. */
        ts = reinterpret_cast<struct t_server *>(pcb.eap.es_server.ea_session);
        if (ts != nullptr)
        {
            // t_serverclose(ts);
            pcb.eap.es_server.ea_session = nullptr;
            pcb.eap.es_server.ea_skey = nullptr;
        }

        if (status != 0)
        {
            pcb.eap.es_server.ea_state = eapBadAuth;
            break;
        }

        /* If we've got a pseudonym, try to decode to real name. */
        if (pcb.eap.es_server.ea_peer.length() > SRP_PSEUDO_LEN && pcb
                                                                    .eap.es_server.
                                                                    ea_peer.find(
                                                                        SRP_PSEUDO_ID) !=
            std::string::npos && (pcb.eap.es_server.ea_peer.length() - SRP_PSEUDO_LEN) *
            3 / 4 < sizeof(secbuf))
        {
            zero_mem(&bs, sizeof(bs));
            // plen = b64dec(&bs, pcb->eap.es_server.ea_peer + SRP_PSEUDO_LEN,
            //               pcb->eap.es_server.ea_peerlen - SRP_PSEUDO_LEN, secbuf);
            int toffs = 0;
            for (i = 0; i < 5; i++)
            {
                pncrypt_setkey(toffs);
                toffs -= 86400;
                /* FIXME: if we want to do SRP, we need to find a way to pass the
                 * PolarSSL des_context instead of using static memory */
                // if (!DesDecrypt(secbuf, clear))
                // {
                //     ppp_dbglog(
                //         "no DES here; cannot decode "
                //         "pseudonym");
                //     return;
                // }
                int id = *(unsigned char *)clear;
                if (id + 1 <= plen && id + 9 > plen)
                {
                    break;
                }
            }
            if (plen % 8 == 0 && i < 5)
            {
                /*
                 * Note that this is always shorter than the
                 * original stored string, so there's no need
                 * to realloc.
                 */
                if ((i = plen = *(unsigned char *)clear) > 7) i = 7;
                // pcb->eap.es_server.ea_peer.length() = plen;
                std::string dp = pcb.eap.es_server.ea_peer;
                // memcpy(dp, clear + 1, i);
                plen -= i;
                dp += i;
                unsigned char* sp = secbuf + 8;
                while (plen > 0)
                {
                    /* FIXME: if we want to do SRP, we need to find a way to pass the
                     * PolarSSL des_context instead of using static memory */
                    // (void)DesDecrypt(sp, dp);
                    sp += 8;
                    dp += 8;
                    plen -= 8;
                }
                pcb.eap.es_server.ea_peer[pcb.eap.es_server.ea_peer.length()] = '\0';
                ppp_dbglog("decoded pseudonym to \"%.*q\"",
                           pcb.eap.es_server.ea_peer.length(), pcb.eap.es_server.ea_peer);
            }
            else
            {
                ppp_dbglog("failed to decode real name");
                /* Stay in eapIdentfy state; requery */
                break;
            }
        }
        /* Look up user in secrets database. */
        // if (get_srp_secret(pcb->eap.es_unit, pcb->eap.es_server.ea_peer,
        //                    pcb->eap.es_server.ea_name, (char *)secbuf, 1) != 0)
        // {
        //     /* Set up default in case SRP entry is bad */
        //     pcb->eap.es_server.ea_state = eapMD5Chall;
        //     /* Get t_confent based on index in srp-secrets */
        //     id = strtol((char *)secbuf, &cp, 10);
        //     if (*cp++ != ':' || id < 0) break;
        //     if (id == 0)
        //     {
        //         mytce.index = 0;
        //         mytce.modulus.data = (uint8_t *)wkmodulus;
        //         mytce.modulus.len = sizeof(wkmodulus);
        //         mytce.generator.data = (uint8_t *)"\002";
        //         mytce.generator.len = 1;
        //         tce = &mytce;
        //     }
        //     else if ((tce = gettcid(id)) != NULL)
        //     {
        //         /*
        //          * Client will have to verify this modulus/
        //          * generator combination, and that will take
        //          * a while.  Lengthen the timeout here.
        //          */
        //         if (pcb->settings.eap_timeout_time > 0 &&
        //             pcb->settings.eap_timeout_time < 30)
        //             pcb->settings.eap_timeout_time = 30;
        //     }
        //     else
        //     {
        //         break;
        //     }
        //     if ((cp2 = strchr(cp, ':')) == nullptr) break;
        //     *cp2++ = '\0';
        //     tpw.pebuf.name = pcb->eap.es_server.ea_peer;
        //     tpw.pebuf.password.len = t_fromb64((char *)tpw.pwbuf, cp);
        //     tpw.pebuf.password.data = tpw.pwbuf;
        //     tpw.pebuf.salt.len = t_fromb64((char *)tpw.saltbuf, cp2);
        //     tpw.pebuf.salt.data = tpw.saltbuf;
        //     if ((ts = t_serveropenraw(&tpw.pebuf, tce)) == NULL) break;
        //     pcb->eap.es_server.ea_session = (uint8_t *)ts;
        //     pcb->eap.es_server.ea_state = eapSRP1;
        //     vals[0] = pcb->eap.es_server.ea_id + 1;
        //     vals[1] = EAPT_SRP;
        //     t_serveraddexdata(ts, vals, 2);
        //     /* Generate B; must call before t_servergetkey() */
        //     t_servergenexp(ts);
        //     break;
        // }

        pcb.eap.es_server.ea_state = eapMD5Chall;
        break;

    case eapSRP1:
        ts = (struct t_server *)pcb.eap.es_server.ea_session;
        if (ts != nullptr && status != 0)
        {
            // t_serverclose(ts);
            pcb.eap.es_server.ea_session = nullptr;
            pcb.eap.es_server.ea_skey = nullptr;
        }
        if (status == 1)
        {
            pcb.eap.es_server.ea_state = eapMD5Chall;
        }
        else if (status != 0 || pcb.eap.es_server.ea_session == nullptr)
        {
            pcb.eap.es_server.ea_state = eapBadAuth;
        }
        else
        {
            pcb.eap.es_server.ea_state = eapSRP2;
        }
        break;

    case eapSRP2:

        ts = (struct t_server *)pcb.eap.es_server.ea_session;
        if (ts != nullptr && status != 0)
        {
            // t_serverclose(ts);
            pcb.eap.es_server.ea_session = nullptr;
            pcb.eap.es_server.ea_skey = nullptr;
        }
        if (status != 0 || pcb.eap.es_server.ea_session == nullptr)
        {
            pcb.eap.es_server.ea_state = eapBadAuth;
        }
        else
        {
            pcb.eap.es_server.ea_state = eapSRP3;
        }
        break;

    case eapSRP3:
    case eapSRP4:

        ts = (struct t_server *)pcb.eap.es_server.ea_session;
        if (ts != nullptr && status != 0)
        {
            // t_serverclose(ts);
            pcb.eap.es_server.ea_session = nullptr;
            pcb.eap.es_server.ea_skey = nullptr;
        }
        if (status != 0 || pcb.eap.es_server.ea_session == nullptr)
        {
            pcb.eap.es_server.ea_state = eapBadAuth;
        }
        else
        {
            pcb.eap.es_server.ea_state = eapOpen;
        }
        break;

    case eapMD5Chall:
        if (status != 0)
        {
            pcb.eap.es_server.ea_state = eapBadAuth;
        }
        else
        {
            pcb.eap.es_server.ea_state = eapOpen;
        }
        break;

    default:
        pcb.eap.es_server.ea_state = eapBadAuth;
        break;
    }
    if (pcb.eap.es_server.ea_state == eapBadAuth) eap_send_failure(pcb);
}

/*
 * Format an EAP Request message and send it to the peer.  Message
 * type depends on current state.  (Server operation)
 */
static void eap_send_request(PppPcb& pcb)
{
    int len;
    const char* str;

    /* Handle both initial auth and restart */
    if (pcb.eap.es_server.ea_state < eapIdentify &&
        pcb.eap.es_server.ea_state != eapInitial)
    {
        pcb.eap.es_server.ea_state = eapIdentify;

        if (pcb.settings.explicit_remote && !pcb.peer_authname.empty())
        {
            /*
             * If we already know the peer's
             * unauthenticated name, then there's no
             * reason to ask.  Go to next state instead.
             */
            auto len = pcb.peer_authname.length();
            if (len > MAXNAMELEN)
            {
                len = MAXNAMELEN;
            }
            // memcpy(pcb->eap.es_server.ea_peer, pcb->peer_authname, len);

            pcb.eap.es_server.ea_peer = pcb.peer_authname;

            // pcb->eap.es_server.ea_peer[len] = '\0';
            // pcb->eap.es_server.ea_peerlen = len;
            eap_figure_next_state(pcb, 0);
        }
    }

    if (pcb.settings.eap_max_transmits > 0 &&
        pcb.eap.es_server.ea_requests >= pcb.settings.eap_max_transmits)
    {
        if (pcb.eap.es_server.ea_responses > 0)
        {
            ppp_error("EAP: too many Requests sent");
        }
        else
        {
            ppp_error("EAP: no response to Requests");
        }
        eap_send_failure(pcb);
        return;
    }

    // p = pbuf_alloc(PBUF_RAW, (uint16_t)(kPppCtrlPbufMaxSize),
    //                PPP_CTRL_PBUF_TYPE);
    struct PacketBuffer* p = new PacketBuffer;
    if (nullptr == p)
    {
        return;
    }
    if (p->tot_len != p->len)
    {
        free_pkt_buf(p);
        return;
    }

    uint8_t* outp = static_cast<uint8_t *>(p->payload);

    MAKEHEADER(outp, PPP_EAP);

    PUTCHAR(EAP_REQUEST, outp);
    PUTCHAR(pcb->eap.es_server.ea_id, outp);
    uint8_t* lenloc = outp;
    INCPTR(2, outp);

    switch (pcb.eap.es_server.ea_state)
    {
    case eapIdentify:
        PUTCHAR(EAPT_IDENTITY, outp);
        str = "Name";
        len = strlen(str);
        memcpy(outp, str, len);
        INCPTR(len, outp);
        break;

    case eapMD5Chall:
        PUTCHAR(EAPT_MD5CHAP, outp);
        /*
         * pick a random challenge length between
         * EAP_MIN_CHALLENGE_LENGTH and EAP_MAX_CHALLENGE_LENGTH
         */
        pcb.eap.es_challen =
            EAP_MIN_CHALLENGE_LENGTH +
            magic_pow(EAP_MIN_MAX_POWER_OF_TWO_CHALLENGE_LENGTH);
        { *(outp)++ = (uint8_t) (pcb.eap.es_challen); };
        magic_random_bytes(pcb.eap.es_challenge, pcb.eap.es_challen);
        memcpy(outp, pcb.eap.es_challenge, pcb.eap.es_challen);
        ((outp) += (pcb.eap.es_challen));
        memcpy(outp, pcb.eap.es_server.ea_name.c_str(), pcb.eap.es_server.ea_name.length());
        // outp = pcb->eap.es_server.ea_name;
        ((outp) += (pcb.eap.es_server.ea_name.length()));
        break;



    default:
        return;
    }

    int outlen = (outp - (unsigned char *)p->payload) - PPP_HDRLEN;
    PUTSHORT(outlen, lenloc);

    // pbuf_realloc(p);
    ppp_write(pcb, p);

    pcb.eap.es_server.ea_requests++;

    if (pcb.settings.eap_timeout_time > 0)
    {
        Timeout(eap_server_timeout, pcb, pcb.settings.eap_timeout_time);
    }
}

/*
 * eap_authpeer - Authenticate our peer (behave as server).
 *
 * Start server state and send first request.  This is called only
 * after eap_lowerup.
 */
void
eap_authpeer(PppPcb& pcb, std::string& localname)
{
    /* Save the name we're given. */
    pcb.eap.es_server.ea_name = localname;
    // pcb->eap.es_server.ea_name.length = strlen(localname);
    pcb.eap.es_savedtime = pcb.settings.eap_timeout_time; /* Lower layer up yet? */
    if (pcb.eap.es_server.ea_state == eapInitial || pcb.eap.es_server.ea_state ==
        eapPending)
    {
        pcb.eap.es_server.ea_state = eapPending;
        return;
    }
    pcb.eap.es_server.ea_state = eapPending;
    /* ID number not updated here intentionally; hashed into M1 */
    eap_send_request(pcb);
}

/*
 * eap_server_timeout - Retransmission timer for sending Requests
 * expired.
 */
static void
eap_server_timeout(void* arg)
{
    auto* pcb = static_cast<PppPcb *>(arg);
    if (!eap_server_active(&pcb->eap))
    {
        return; /* EAP ID number must not change on timeout. */
    }
    eap_send_request(pcb);
}

/*
 * When it's time to send rechallenge the peer, this timeout is
 * called.  Once the rechallenge is successful, the response handler
 * will restart the timer.  If it fails, then the link is dropped.
 */
static void eap_rechallenge(void* arg) {
  PppPcb *pcb = (PppPcb *)arg;

  if (pcb->eap.es_server.ea_state != eapOpen &&
      pcb->eap.es_server.ea_state != eapSRP4)
  {
      return;
  }
  pcb->eap.es_server.ea_requests = 0;
  pcb->eap.es_server.ea_state = eapIdentify;
  eap_figure_next_state(pcb, 0);
  pcb->eap.es_server.ea_id++;
  eap_send_request(pcb);
}

static void srp_lwrechallenge(void* arg) {
  PppPcb *pcb = (PppPcb *)arg;

  if (pcb->eap.es_server.ea_state != eapOpen ||
      pcb->eap.es_server.ea_type != EAPT_SRP)
  {
      return;
  }
  pcb->eap.es_server.ea_requests = 0;
  pcb->eap.es_server.ea_state = eapSRP4;
  pcb->eap.es_server.ea_id++;
  eap_send_request(pcb);
}


/*
 * eap_lowerup - The lower layer is now up.
 *
 * This is called before either eap_authpeer or eap_authwithpeer.  See
 * link_established() in auth.c.  All that's necessary here is to
 * return to closed state so that those two routines will do the right
 * thing.
 */
static void eap_lowerup(PppPcb* pcb)
{
    pcb->eap.es_client.ea_state = eapClosed;

    pcb->eap.es_server.ea_state = eapClosed;
}

/*
 * eap_lowerdown - The lower layer is now down.
 *
 * Cancel all timeouts and return to initial state.
 */
static void eap_lowerdown(PppPcb *pcb) {
  if (eap_client_active(pcb) && pcb->settings.eap_req_time > 0) {
    Untimeout(eap_client_timeout, pcb);
  }

  if (eap_server_active(&pcb->eap)) {
    if (pcb->settings.eap_timeout_time > 0) {
      Untimeout(eap_server_timeout, pcb);
    }
  } else {
    if ((pcb->eap.es_server.ea_state == eapOpen ||
         pcb->eap.es_server.ea_state == eapSRP4) &&
        pcb->eap.es_rechallenge > 0) {
      Untimeout(eap_rechallenge, (uint8_t *)pcb);
    }
    if (pcb->eap.es_server.ea_state == eapOpen &&
        pcb->eap.es_lwrechallenge > 0) {
      Untimeout(srp_lwrechallenge, (uint8_t *)pcb);
    }
  }

  pcb->eap.es_client.ea_state = pcb->eap.es_server.ea_state = eapInitial;
  pcb->eap.es_client.ea_requests = pcb->eap.es_server.ea_requests = 0;

}

/*
 * eap_protrej - Peer doesn't speak this protocol.
 *
 * This shouldn't happen.  If it does, it represents authentication
 * failure.
 */
static void eap_protrej(PppPcb* pcb)
{
    if (eap_client_active(pcb))
    {
        ppp_error("EAP authentication failed due to Protocol-Reject");
        auth_withpeer_fail(pcb, PPP_EAP);
    }

    if (eap_server_active(&pcb->eap))
    {
        ppp_error("EAP authentication of peer failed on Protocol-Reject");
        auth_peer_fail(pcb, PPP_EAP);
    }

    eap_lowerdown(pcb);
}

/*
 * Format and send a regular EAP Response message.
 */
static void
eap_send_response(PppPcb* pcb, uint8_t id, uint8_t typenum, std::string& str)
{
    const auto msglen = EAP_HEADERLEN + sizeof(uint8_t) + str.length();
    // p = pbuf_alloc(PBUF_RAW, (uint16_t)(PPP_HDRLEN + msglen), PPP_CTRL_PBUF_TYPE);
    auto* p = new PacketBuffer;
    if (nullptr == p)
    {
        return;
    }
    if (p->tot_len != p->len)
    {
        free_pkt_buf(p);
        return;
    }
    auto outp = p->payload;
    MAKEHEADER(outp, PPP_EAP);
    PUTCHAR(EAP_RESPONSE, outp);
    PUTCHAR(id, outp);
    pcb->eap.es_client.ea_id = id;
    PUTSHORT(msglen, outp);
    PUTCHAR(typenum, outp);
    if (str.length() > 0)
    {
        memcpy(outp, str.c_str(), str.length());
    }
    ppp_write(pcb, p);
}

/*
 * Format and send an MD5-Challenge EAP Response message.
 */
static void eap_chap_response(PppPcb* pcb,
                              uint8_t id,
                              uint8_t* hash,
                              std::string& name)
{
    const auto msglen = EAP_HEADERLEN + 2 * sizeof(uint8_t) + MD5_SIGNATURE_SIZE + name.length();
    // p = pbuf_alloc(PBUF_RAW, (uint16_t)(PPP_HDRLEN + msglen), PPP_CTRL_PBUF_TYPE);
    auto* p = new PacketBuffer;
    if (nullptr == p)
    {
        return;
    }
    if (p->tot_len != p->len)
    {
        free_pkt_buf(p);
        return;
    }
    auto outp = p->payload;

    MAKEHEADER(outp, PPP_EAP);

    PUTCHAR(EAP_RESPONSE, outp);
    PUTCHAR(id, outp);
    pcb->eap.es_client.ea_id = id;
    PUTSHORT(msglen, outp);
    PUTCHAR(EAPT_MD5CHAP, outp);
    PUTCHAR(MD5_SIGNATURE_SIZE, outp);
    memcpy(outp, hash, MD5_SIGNATURE_SIZE);
    INCPTR(MD5_SIGNATURE_SIZE, outp);
    if (name.length() > 0)
    {
        memcpy(outp, name.c_str(), name.length());
    }

    ppp_write(pcb, p);
}

static void eap_send_nak(PppPcb* pcb, uint8_t id, uint8_t type)
{
    int msglen = EAP_HEADERLEN + 2 * sizeof(uint8_t);
    // p = pbuf_alloc(PBUF_RAW, (uint16_t)(PPP_HDRLEN + msglen), PPP_CTRL_PBUF_TYPE);
    struct PacketBuffer* p = new PacketBuffer;
    if (nullptr == p)
    {
        return;
    }
    if (p->tot_len != p->len)
    {
        free_pkt_buf(p);
        return;
    }

    uint8_t* outp = (uint8_t *)p->payload;

    MAKEHEADER(outp, PPP_EAP);

    PUTCHAR(EAP_RESPONSE, outp);
    PUTCHAR(id, outp);
    pcb->eap.es_client.ea_id = id;
    PUTSHORT(msglen, outp);
    PUTCHAR(EAPT_NAK, outp);
    PUTCHAR(type, outp);

    ppp_write(pcb, p);
}

/*
 * eap_request - Receive EAP Request message (client mode).
 */
static void eap_request(PppPcb* pcb, uint8_t* inp, int id, size_t len)
{
    uint8_t typenum;
    uint8_t vallen;
    std::string secret;
    std::string rhostname;
    mbedtls_md5_context mdContext;
    uint8_t hash[MD5_SIGNATURE_SIZE] = {};
    /*
     * Note: we update es_client.ea_id *only if* a Response
     * message is being generated.  Otherwise, we leave it the
     * same for duplicate detection purposes.
     */

    pcb->eap.es_client.ea_requests++;
    if (pcb->settings.eap_allow_req != 0 &&
        pcb->eap.es_client.ea_requests > pcb->settings.eap_allow_req)
    {
        ppp_info("EAP: received too many Request messages");
        if (pcb->settings.eap_req_time > 0)
        {
            Untimeout(eap_client_timeout, pcb);
        }
        auth_withpeer_fail(pcb, PPP_EAP);
        return;
    }

    if (len <= 0)
    {
        ppp_error("EAP: empty Request message discarded");
        return;
    }

    GETCHAR(typenum, inp);
    len--;

    std::string empty_str;

    switch (typenum)
    {
    case EAPT_IDENTITY:
        if (len > 0) ppp_info("EAP: Identity prompt \"%.*q\"", len, inp);

        eap_send_response(pcb, id, typenum,
                          pcb->eap.es_client.ea_name);
        break;

    case EAPT_NOTIFICATION:
        if (len > 0)
        {
            ppp_info("EAP: Notification \"%.*q\"", len, inp);
        }
        eap_send_response(pcb, id, typenum, empty_str);
        break;

    case EAPT_NAK:
        /*
         * Avoid the temptation to send Response Nak in reply
         * to Request Nak here.  It can only lead to trouble.
         */
        ppp_warn("EAP: unexpected Nak in Request; ignored");
        /* Return because we're waiting for something real. */
        return;

    case EAPT_MD5CHAP:
        if (len < 1)
        {
            ppp_error("EAP: received MD5-Challenge with no data");
            /* Bogus request; wait for something real. */
            return;
        }
        GETCHAR(vallen, inp);
        len--;
        if (vallen < 8 || vallen > len)
        {
            ppp_error("EAP: MD5-Challenge with bad length %d (8..%d)", vallen, len);
            /* Try something better. */
            eap_send_nak(pcb, id, EAPT_SRP);
            break;
        }

        /* Not so likely to happen. */
        // if (vallen >= len + rhostname.length())
        // {
        //     ppp_dbglog("EAP: trimming really long peer name down");
        //     memcpy(rhostname, inp + vallen, sizeof(rhostname) - 1);
        //     rhostname[sizeof(rhostname) - 1] = '\0';
        // }
        // else
        // {
        //     memcpy(rhostname, inp + vallen, len - vallen);
        //     rhostname[len - vallen] = '\0';
        // }

        /* In case the remote doesn't give us his name. */
        if (pcb->settings.explicit_remote ||
            (pcb->settings.remote_name[0] != '\0' && vallen == len))
        {
            rhostname = pcb->settings.remote_name;
        } /*
         * Get the secret for authenticating ourselves with
         * the specified host.
         */
        if (!get_secret(pcb, pcb->eap.es_client.ea_name, rhostname, secret))
        {
            ppp_dbglog("EAP: no MD5 secret for auth to %q", rhostname);
            eap_send_nak(pcb, id, EAPT_SRP);
            break;
        }
        mbedtls_md5_init(&mdContext);
        mbedtls_md5_starts_ret(&mdContext);
        typenum = id;
        mbedtls_md5_update_ret(&mdContext, &typenum, 1);
        mbedtls_md5_update_ret(&mdContext, (uint8_t *)secret.c_str(), secret.length());
        // BZERO(secret, sizeof(secret));
        mbedtls_md5_update_ret(&mdContext, inp, vallen);
        mbedtls_md5_finish_ret(&mdContext, hash);
        mbedtls_md5_free(&mdContext);
        eap_chap_response(pcb, id, hash, pcb->eap.es_client.ea_name);
        break;

    default:
        ppp_info("EAP: unknown authentication type %d; Naking", typenum);
        eap_send_nak(pcb, id, EAPT_SRP);
        break;
    }

    if (pcb->settings.eap_req_time > 0)
    {
        Untimeout(eap_client_timeout, pcb);
        Timeout(eap_client_timeout, pcb, pcb->settings.eap_req_time);
    }
}


/*
 * eap_response - Receive EAP Response message (server mode).
 */
static void eap_response(PppPcb* pcb, const char* inp, int id, int len)
{
    uint8_t typenum;
    uint8_t vallen;
    int secret_len;
    std::string secret;
    std::string rhostname;
    mbedtls_md5_context md_context;
    uint8_t hash[MD5_SIGNATURE_SIZE] ={};


    if (pcb->eap.es_server.ea_id != id)
    {
        ppp_dbglog("EAP: discarding Response %d; expected ID %d", id,
                   pcb->eap.es_server.ea_id);
        return;
    }

    pcb->eap.es_server.ea_responses++;

    if (len <= 0)
    {
        ppp_error("EAP: empty Response message discarded");
        return;
    }

    GETCHAR(typenum, inp);
    len--;

    switch (typenum)
    {
    case EAPT_IDENTITY:
        if (pcb->eap.es_server.ea_state != eapIdentify)
        {
            ppp_dbglog("EAP discarding unwanted Identify \"%.q\"", len, inp);
            break;
        }
        ppp_info("EAP: unauthenticated peer name \"%.*q\"", len, inp);
        if (len > MAXNAMELEN)
        {
            len = MAXNAMELEN;
        }
        // memcpy(pcb->eap.es_server.ea_peer, inp, len);
        pcb->eap.es_server.ea_peer = inp;
        // pcb->eap.es_server.ea_peer[len] = '\0';
        // pcb->eap.es_server.ea_peer.length() = len;
        eap_figure_next_state(pcb, 0);
        break;

    case EAPT_NOTIFICATION:
        ppp_dbglog("EAP unexpected Notification; response discarded");
        break;

    case EAPT_NAK:
        if (len < 1)
        {
            ppp_info("EAP: Nak Response with no suggested protocol");
            eap_figure_next_state(pcb, 1);
            break;
        }

        GETCHAR(vallen, inp);
        len--;

        // if (
        //
        //     !pcb->explicit_remote &&
        //
        //     pcb->eap.es_server.ea_state == eapIdentify) {
        //   /* Peer cannot Nak Identify Request */
        //   eap_figure_next_state(pcb, 1);
        //   break;
        // }

        switch (vallen)
        {
        case EAPT_SRP:
            /* Run through SRP validator selection again. */
            pcb->eap.es_server.ea_state = eapIdentify;
            eap_figure_next_state(pcb, 0);
            break;

        case EAPT_MD5CHAP:
            pcb->eap.es_server.ea_state = eapMD5Chall;
            break;

        default:
            ppp_dbglog("EAP: peer requesting unknown Type %d", vallen);
            switch (pcb->eap.es_server.ea_state)
            {
            case eapSRP1:
            case eapSRP2:
            case eapSRP3:
                pcb->eap.es_server.ea_state = eapMD5Chall;
                break;
            case eapMD5Chall:
            case eapSRP4:
                pcb->eap.es_server.ea_state = eapIdentify;
                eap_figure_next_state(pcb, 0);
                break;
            default:
                break;
            }
            break;
        }
        break;

    case EAPT_MD5CHAP:
        if (pcb->eap.es_server.ea_state != eapMD5Chall)
        {
            ppp_error("EAP: unexpected MD5-Response");
            eap_figure_next_state(pcb, 1);
            break;
        }
        if (len < 1)
        {
            ppp_error("EAP: received MD5-Response with no data");
            eap_figure_next_state(pcb, 1);
            break;
        }
        GETCHAR(vallen, inp);
        len--;
        if (vallen != 16 || vallen > len)
        {
            ppp_error("EAP: MD5-Response with bad length %d", vallen);
            eap_figure_next_state(pcb, 1);
            break;
        }

        /* Not so likely to happen. */
        if (vallen >= len + sizeof(rhostname))
        {
            ppp_dbglog("EAP: trimming really long peer name down");
            rhostname = (char*)(inp + vallen);
            // memcpy(rhostname, inp + vallen, sizeof(rhostname) - 1);
            // rhostname[sizeof(rhostname) - 1] = '\0';
        }
        else
        {
            // memcpy(rhostname, inp + vallen, len - vallen);
            rhostname = (char*)(inp + vallen);
            // rhostname[len - vallen] = '\0';
        }

        /* In case the remote doesn't give us his name. */
        // if (explicit_remote || (remote_name[0] != '\0' && vallen == len))
        //   strlcpy(rhostname, remote_name, sizeof(rhostname));


        /*
         * Get the secret for authenticating the specified
         * host.
         */
        if (!get_secret(pcb, rhostname, pcb->eap.es_server.ea_name, secret))
        {
            ppp_dbglog("EAP: no MD5 secret for auth of %q", rhostname);
            eap_send_failure(pcb);
            break;
        }
        mbedtls_md5_init(&mdContext);
        mbedtls_md5_starts_ret(&md_context);
        md5_update(&md_context, &pcb->eap.es_server.ea_id, 1);
        md5_update(&md_context, (uint8_t*)secret.c_str(), secret.length());
        // BZERO(secret, sizeof(secret));
        mbedtls_md5_update_ret(&md_context, pcb->eap.es_challenge, pcb->eap.es_challen);
        mbedtls_md5_finish_ret(&md_context, hash);
        mbedtls_md5_free(&mdContext);
        if (BCMP(hash, inp, MD5_SIGNATURE_SIZE) != 0)
        {
            eap_send_failure(pcb);
            break;
        }
        pcb->eap.es_server.ea_type = EAPT_MD5CHAP;
        eap_send_success(pcb);
        eap_figure_next_state(pcb, 0);
        if (pcb->eap.es_rechallenge != 0)
        {
            Timeout(eap_rechallenge, pcb, pcb->eap.es_rechallenge);
        }
        break;


    default:
        /* This can't happen. */
        ppp_error("EAP: unknown Response type %d; ignored", typenum);
        return;
    }

    if (pcb->settings.eap_timeout_time > 0)
    {
        Untimeout(eap_server_timeout, pcb);
    }

    if (pcb->eap.es_server.ea_state != eapBadAuth &&
        pcb->eap.es_server.ea_state != eapOpen)
    {
        pcb->eap.es_server.ea_id++;
        eap_send_request(pcb);
    }
}


/*
 * eap_success - Receive EAP Success message (client mode).
 */
static void eap_success(PppPcb* pcb, uint8_t* inp, int id, int len)
{
    if (pcb->eap.es_client.ea_state != eapOpen && !eap_client_active(pcb))
    {
        ppp_dbglog("EAP unexpected success message in state %s (%d)",
                   eap_state_name(pcb->eap.es_client.ea_state),
                   pcb->eap.es_client.ea_state);
        return;
    }

    if (pcb->settings.eap_req_time > 0)
    {
        Untimeout(eap_client_timeout, pcb);
    }

    if (len > 0)
    {
        /* This is odd.  The spec doesn't allow for this. */
        PRINTMSG(inp, len);
    }

    pcb->eap.es_client.ea_state = eapOpen;
    auth_withpeer_success(pcb, PPP_EAP, 0);
}

/*
 * eap_failure - Receive EAP Failure message (client mode).
 */
static void eap_failure(PppPcb* pcb, uint8_t* inp, int id, int len)
{
    if (!eap_client_active(pcb))
    {
        ppp_dbglog("EAP unexpected failure message in state %s (%d)",
                   eap_state_name(pcb->eap.es_client.ea_state),
                   pcb->eap.es_client.ea_state);
    }

    if (pcb->settings.eap_req_time > 0)
    {
        Untimeout(eap_client_timeout, pcb);
    }

    if (len > 0)
    {
        /* This is odd.  The spec doesn't allow for this. */
        PRINTMSG(inp, len);
    }

    pcb->eap.es_client.ea_state = eapBadAuth;

    ppp_error("EAP: peer reports authentication failure");
    auth_withpeer_fail(pcb, PPP_EAP);
}

/*
 * eap_input - Handle received EAP message.
 */
static void eap_input(PppPcb* pcb, uint8_t* inp, int inlen, Protent** protocols)
{
    uint8_t code, id;
    int len; /*
   * Parse header (code, id and length).  If packet too short,
   * drop it.
   */
    if (inlen < EAP_HEADERLEN)
    {
        ppp_error("EAP: packet too short: %d < %d", inlen, EAP_HEADERLEN);
        return;
    }
    GETCHAR(code, inp);
    GETCHAR(id, inp);
    GETSHORT(len, inp);
    if (len < EAP_HEADERLEN || len > inlen)
    {
        ppp_error("EAP: packet has illegal length field %d (%d..%d)",
                  len,
                  EAP_HEADERLEN,
                  inlen);
        return;
    }
    len -= EAP_HEADERLEN; /* Dispatch based on message code */
    switch (code)
    {
    case EAP_REQUEST:
        eap_request(pcb, inp, id, len);
        break;

    case EAP_RESPONSE:
        eap_response(pcb, (char*)inp, id, len);
        break;

    case EAP_SUCCESS:
        eap_success(pcb, inp, id, len);
        break;
    case EAP_FAILURE:
        eap_failure(pcb, inp, id, len);
        break;
    default: /* XXX Need code reject */ /* Note: it's not legal to send EAP Nak here. */
        ppp_warn("EAP: unknown code %d received", code);
        break;
    }
}

//
// END OF FILE
//