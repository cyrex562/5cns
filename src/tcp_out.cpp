/**
 * @file
 * Transmission Control Protocol, outgoing traffic
 *
 * The output functions of TCP.
 *
 * There are two distinct ways for TCP segments to get sent:
 * - queued data: these are segments transferring data or segments containing
 *   SYN or FIN (which both count as one sequence number). They are created as
 *   struct @ref PacketBuffer together with a struct tcp_seg and enqueue to the
 *   unsent list of the pcb. They are sent by tcp_output:
 *   - @ref tcp_write : creates data segments
 *   - @ref tcp_split_unsent_seg : splits a data segment
 *   - @ref tcp_enqueue_flags : creates SYN-only or FIN-only segments
 *   - @ref tcp_output / tcp_output_segment : finalize the tcp header
 *      (e.g. sequence numbers, options, checksum) and output to IP
 *   - the various tcp_rexmit functions shuffle around segments between the
 *     unsent an unacked lists to retransmit them
 *   - tcp_create_segment and tcp_pbuf_prealloc allocate PacketBuffer and
 *     segment for these functions
 * - direct send: these segments don't contain data but control the connection
 *   behaviour. They are created as PacketBuffer only and sent directly without
 *   enqueueing them:
 *   - @ref tcp_send_empty_ack sends an ACK-only segment
 *   - @ref tcp_rst sends a RST segment
 *   - @ref tcp_keepalive sends a keepalive segment
 *   - @ref tcp_zero_window_probe sends a window probe segment
 *   - tcp_output_alloc_header allocates a header-only PacketBuffer for these functions
 */

/*
 * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 * This file is part of the lwIP TCP/IP stack.
 *
 * Author: Adam Dunkels <adam@sics.se>
 *
 */

#include <cstring>
#include <def.h>
#include <inet_chksum.h>
#include <ip6.h>
#include <ip6_addr.h>
#include <ip_addr.h>
#include <lwip_debug.h>
#include <network_interface.h>
#include <opt.h>
#include <sys.h>
#include <tcp_priv.h>


/* Allow to add custom TCP header options by defining this hook */

// #define LWIP_TCP_OPT_LENGTH_SEGMENT(flags, pcb) LWIP_HOOK_TCP_OUT_TCPOPT_LENGTH(pcb, LWIP_TCP_OPT_LENGTH(flags))


static void
tcp_seg_add_chksum(uint16_t chksum, uint16_t len, uint16_t *seg_chksum,
                   uint8_t *seg_chksum_swapped);

/* Define some copy-macros for checksum-on-copy so that the code looks
   nicer by preventing too many ifdef's. */
inline void
TCP_DATA_COPY(uint8_t* dst, uint8_t* src, size_t len, TcpSeg* seg)
{
    tcp_seg_add_chksum(lwip_standard_checksum_copy(dst, src, len),
                       len,
                       &seg->chksum,
                       &seg->chksum_swapped);
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
}

inline void
TCP_DATA_COPY2(uint8_t* dst,
               uint8_t* src,
               size_t len,
               uint16_t* chksum,
               uint8_t* chksum_swapped)
{
    tcp_seg_add_chksum(lwip_standard_checksum_copy(dst, src, len),
                       len,
                       chksum,
                       chksum_swapped);
}

/** Define this to 1 for an extra check that the output checksum is valid
 * (usefule when the checksum is generated by the application, not the stack) */

/* Allow to override the failure of sanity check from warning to e.g. hard failure */

#define TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL(msg) Logf(true | LWIP_DBG_LEVEL_WARNING, msg)



#define TCP_OVERSIZE_CALC_LENGTH(length) ((length) + TCP_OVERSIZE)


/* Forward declarations.*/
static LwipStatus tcp_output_segment(struct TcpSeg *seg, struct TcpPcb *pcb, NetworkInterface*netif);

/* tcp_route: common code that returns a fixed bound netif or calls ip_route */
static NetworkInterface*
tcp_route(const struct TcpPcb *pcb, const IpAddrInfo *src, const IpAddrInfo *dst)
{
    if ((pcb != nullptr) && (pcb->netif_idx != NETIF_NO_INDEX)) {
    // return get_netif_by_index(pcb->netif_idx);
  } else {
    return ip_route(src, dst);
  }
}

/**
 * Create a TCP segment with prefilled header.
 *
 * Called by @ref tcp_write, @ref tcp_enqueue_flags and @ref tcp_split_unsent_seg
 *
 * @param pcb Protocol control block for the TCP connection.
 * @param p PacketBuffer that is used to hold the TCP header.
 * @param hdrflags TCP flags for header.
 * @param seqno TCP sequence number of this packet
 * @param optflags options to include in TCP header
 * @return a new tcp_seg pointing to p, or NULL.
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct TcpSeg*
tcp_create_segment(const struct TcpPcb* pcb,
                   struct PacketBuffer* p,
                   uint8_t hdrflags,
                   uint32_t seqno,
                   uint8_t optflags)
{
    lwip_assert("tcp_create_segment: invalid pcb", pcb != nullptr);
    lwip_assert("tcp_create_segment: invalid pbuf", p != nullptr);
    // uint8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
    size_t optlen = 0;
    struct TcpSeg* seg = new TcpSeg;
    if (seg == nullptr)
    {
        Logf(true | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
        free_pkt_buf(p);
        return nullptr;
    }
    seg->flags = optflags;
    seg->next = nullptr;
    seg->p = p;
    lwip_assert("p->tot_len >= optlen", p->tot_len >= optlen);
    seg->len = p->tot_len - optlen;
    // seg->oversize_left = 0;
    seg->chksum = 0;
    seg->chksum_swapped = 0; /* check optflags */
    lwip_assert("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
                (optflags & TF_SEG_DATA_CHECKSUMMED) == 0); /* build TCP header */
    // if (pbuf_add_header(p, TCP_HDR_LEN))
    // {
    //     Logf(true | LWIP_DBG_LEVEL_SERIOUS,
    //          ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    //     tcp_seg_free(seg);
    //     return nullptr;
    // }
    seg->tcphdr = (struct TcpHdr *)seg->p->payload;
    seg->tcphdr->src = lwip_htons(pcb->local_port);
    seg->tcphdr->dest = lwip_htons(pcb->remote_port);
    seg->tcphdr->seqno = lwip_htonl(seqno); /* ackno is set in tcp_output */
    TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
    /* wnd and chksum are set in tcp_output */
    seg->tcphdr->urgp = 0;
    return seg;
}

/**
 * Allocate a PBUF_RAM PacketBuffer, perhaps with extra space at the end.
 *
 * This function is like pbuf_alloc(layer, length, PBUF_RAM) except
 * there may be extra bytes available at the end.
 *
 * Called by @ref tcp_write
 *
 * @param layer flag to define header size.
 * @param length size of the PacketBuffer's payload.
 * @param max_length maximum usable size of payload+oversize.
 * @param oversize pointer to a uint16_t that will receive the number of usable tail bytes.
 * @param pcb The TCP connection that will enqueue the PacketBuffer.
 * @param apiflags API flags given to tcp_write.
 * @param first_seg true when this PacketBuffer will be used in the first enqueued segment.
 */
static struct PacketBuffer*
tcp_pbuf_prealloc(
    size_t length,
    size_t max_length,
    size_t* oversize,
    const struct TcpPcb* pcb,
    uint8_t apiflags,
    uint8_t first_seg)
{
    size_t alloc = length;
    lwip_assert("tcp_pbuf_prealloc: invalid oversize", oversize != nullptr);
    lwip_assert("tcp_pbuf_prealloc: invalid pcb", pcb != nullptr);
    if (length < max_length)
    {
        /* Should we allocate an oversized PacketBuffer, or just the minimum
         * length required? If tcp_write is going to be called again
         * before this segment is transmitted, we want the oversized
         * buffer. If the segment will be transmitted immediately, we can
         * save memory by allocating only length. We use a simple
         * heuristic based on the following information:
         *
         * Did the user set TCP_WRITE_FLAG_MORE?
         *
         * Will the Nagle algorithm defer transmission of this segment?
         */
        if ((apiflags & TCP_WRITE_FLAG_MORE) || (!(pcb->flags & TF_NODELAY) && (!first_seg
            || pcb->unsent != nullptr || pcb->unacked != nullptr)))
        {
            alloc = std::min(max_length,
                             (TCP_OVERSIZE_CALC_LENGTH(length)));
        }
    }
    // struct PacketBuffer* p = pbuf_alloc();
    PacketBuffer p{};
    if (p == nullptr)
    {
        return nullptr;
    }
    lwip_assert("need unchained pbuf", p->next == nullptr);
    *oversize = p->len - length; /* trim p->len to the currently used size */
    p->len = p->tot_len = length;
    return p;
}


/** Add a checksum of newly added data to the segment.
 *
 * Called by tcp_write and tcp_split_unsent_seg.
 */
static void
tcp_seg_add_chksum(uint16_t chksum, uint16_t len, uint16_t *seg_chksum,
                   uint8_t *seg_chksum_swapped)
{
    /* add chksum to old chksum and fold to uint16_t */
  uint32_t helper = chksum + *seg_chksum;
  chksum = fold_u32(helper);
  if ((len & 1) != 0) {
    *seg_chksum_swapped = 1 - *seg_chksum_swapped;
    chksum = SWAP_BYTES_IN_WORD(chksum);
  }
  *seg_chksum = chksum;
}


/** Checks if tcp_write is allowed or not (checks state, snd_buf and snd_queuelen).
 *
 * @param pcb the tcp pcb to check for
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another LwipStatus otherwise
 */
static LwipStatus
tcp_write_checks(struct TcpPcb* pcb, uint16_t len)
{
    lwip_assert("tcp_write_checks: invalid pcb", pcb != nullptr);
    /* connection is in invalid state for data transmission? */
    if ((pcb->state != ESTABLISHED) && (pcb->state != CLOSE_WAIT) && (pcb->state !=
        SYN_SENT) && (pcb->state != SYN_RCVD))
    {
        Logf(true,
             ("tcp_write() called in invalid state\n"));
        return ERR_CONN;
    }
    else if (len == 0)
    {
        return STATUS_OK;
    } /* fail on too much data */
    if (len > pcb->snd_buf)
    {
        Logf(true,
             "tcp_write: too much data (len=%d > snd_buf=%d)\n", len, pcb->snd_buf);
        tcp_set_flags(pcb, TF_NAGLEMEMERR);
        return ERR_MEM;
    }
    Logf(true, "tcp_write: queuelen: %d\n", pcb->snd_queuelen);
    /* If total number of pbufs on the unsent/unacked queues exceeds the
      * configured maximum, return an error */
    /* check for configured max queuelen and possible overflow */
    if (pcb->snd_queuelen >= std::min(TCP_SND_QUEUELEN, (1 + 1)))
    {
        Logf(true,
             "tcp_write: too long queue %d (max %d)\n", pcb->snd_queuelen, (uint16_t)
                 TCP_SND_QUEUELEN);
        // TCP_STATS_INC(tcp.memerr);
        tcp_set_flags(pcb, TF_NAGLEMEMERR);
        return ERR_MEM;
    }
    if (pcb->snd_queuelen != 0)
    {
        lwip_assert("tcp_write: pbufs on queue => at least one queue non-empty",
                    pcb->unacked != nullptr || pcb->unsent != nullptr);
    }
    else
    {
        lwip_assert("tcp_write: no pbufs on queue => both queues empty",
                    pcb->unacked == nullptr && pcb->unsent == nullptr);
    }
    return STATUS_OK;
}

/**
 * @ingroup tcp_raw
 * Write data for sending (but does not send it immediately).
 *
 * It waits in the expectation of more data being sent soon (as
 * it can send them more efficiently by combining them together).
 * To prompt the system to send data now, call tcp_output() after
 * calling tcp_write().
 *
 * This function enqueues the data pointed to by the argument dataptr. The length of
 * the data is passed as the len parameter. The apiflags can be one or more of:
 * - TCP_WRITE_FLAG_COPY: indicates whether the new memory should be allocated
 *   for the data to be copied into. If this flag is not given, no new memory
 *   should be allocated and the data should only be referenced by pointer. This
 *   also means that the memory behind dataptr must not change until the data is
 *   ACKed by the remote host
 * - TCP_WRITE_FLAG_MORE: indicates that more data follows. If this is omitted,
 *   the PSH flag is set in the last segment created by this call to tcp_write.
 *   If this flag is given, the PSH flag is not set.
 *
 * The tcp_write() function will fail and return ERR_MEM if the length
 * of the data exceeds the current send buffer size or if the length of
 * the queue of outgoing segment is larger than the upper limit defined
 * in lwipopts.h. The number of bytes available in the output queue can
 * be retrieved with the tcp_sndbuf() function.
 *
 * The proper way to use this function is to call the function with at
 * most tcp_sndbuf() bytes of data. If the function returns ERR_MEM,
 * the application should wait until some of the currently enqueued
 * data has been successfully received by the other host and try again.
 *
 * @param pcb Protocol control block for the TCP connection to enqueue data for.
 * @param arg Pointer to the data to be enqueued for sending.
 * @param len Data length in bytes
 * @param apiflags combination of following flags :
 * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
 * @return ERR_OK if enqueued, another LwipStatus on error
 */
LwipStatus
tcp_write(struct TcpPcb* pcb, const void* arg, size_t len, uint8_t apiflags)
{
    struct PacketBuffer concat_p;
    struct TcpSeg *last_unsent = nullptr, *seg = nullptr, *prev_seg = nullptr, *queue =
                      nullptr;
    uint16_t pos = 0; /* position in 'arg' data */
    size_t optlen;
    uint8_t optflags = 0;
    size_t oversize = 0;
    uint16_t oversize_used = 0;
    uint16_t oversize_add = 0;
    size_t extendlen = 0;
    uint16_t concat_chksum = 0;
    uint8_t concat_chksum_swapped = 0;
    uint16_t concat_chksummed = 0;
    /* don't allocate segments bigger than half the maximum window we ever received */
    uint16_t mss_local = std::min(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max / 2));
    mss_local = mss_local ? mss_local : pcb->mss;
    Logf(true,
         "tcp_write(pcb=%p, data=%p, len=%d, apiflags=%d)\n",
         (void *)pcb,
         arg,
         len,
         (uint16_t)apiflags);
    LwipStatus err = tcp_write_checks(pcb, len);
    if (err != STATUS_OK)
    {
        return err;
    }
    uint16_t queuelen = pcb->snd_queuelen;
    if ((pcb->flags & TF_TIMESTAMP))
    {
        /* Make sure the timestamp option is only included in data segments if we
           agreed about it with the remote host. */
        optflags = TF_SEG_OPTS_TS;
        // optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(TF_SEG_OPTS_TS, pcb);
        /* ensure that segments can hold at least one data byte... */
        mss_local = std::max(mss_local, uint16_t(LWIP_TCP_OPT_LEN_TS + 1));
    }
    else
    {
        // optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
    } /*
   * TCP segmentation is done in three phases with increasing complexity:
   *
   * 1. Copy data directly into an oversized PacketBuffer.
   * 2. Chain a new PacketBuffer to the end of pcb->unsent.
   * 3. Create new segments.
   *
   * We may run out of memory at any point. In that case we must
   * return ERR_MEM and not change anything in pcb. Therefore, all
   * changes are recorded in local variables and committed at the end
   * of the function. Some pcb fields are maintained in local copies:
   *
   * queuelen = pcb->snd_queuelen
   * oversize = pcb->unsent_oversize
   *
   * These variables are set consistently by the phases:
   *
   * seg points to the last segment tampered with.
   *
   * pos records progress as data is segmented.
   */ /* Find the tail of the unsent queue. */
    if (pcb->unsent != nullptr)
    {
        size_t space = mss_local - last_unsent->len;
        /* @todo: this could be sped up by keeping last_unsent in the pcb */
        for (last_unsent = pcb->unsent; last_unsent->next != nullptr; last_unsent =
             last_unsent->next)
        {
            ;
        } /* Usable space at the end of the last unsent segment */
        // uint16_t unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
        // lwip_assert("mss_local is too small",
        //             mss_local >= last_unsent->len + unsent_optlen);
        // uint16_t space = mss_local - (last_unsent->len + unsent_optlen);
        /*
     * Phase 1: Copy data directly into an oversized PacketBuffer.
     *
     * The number of bytes copied is recorded in the oversize_used
     * variable. The actual copying is done at the bottom of the
     * function.
     */
        oversize = pcb->unsent_oversize;
        if (oversize > 0)
        {
            lwip_assert("inconsistent oversize vs. space", oversize <= space);
            seg = last_unsent;
            oversize_used = std::min(space, std::min(oversize, len));
            pos += oversize_used;
            oversize -= oversize_used;
            space -= oversize_used;
        } /* now we are either finished or oversize is zero */
        lwip_assert("inconsistent oversize vs. len", (oversize == 0) || (pos == len)); /*
     * Phase 2: Chain a new PacketBuffer to the end of pcb->unsent.
     *
     * As an exception when NOT copying the data, if the given data buffer
     * directly follows the last unsent data buffer in memory, extend the last
     * ROM PacketBuffer reference to the buffer, thus saving a ROM PacketBuffer allocation.
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new PacketBuffer is kept in concat_p and pbuf_cat'ed at
     * the end.
     *
     * This phase is skipped for LWIP_NETIF_TX_SINGLE_PBUF as we could only execute
     * it after rexmit puts a segment from unacked to unsent and at this point,
     * oversize info is lost.
     */
        if ((pos < len) && (space > 0) && (last_unsent->len > 0))
        {
            uint16_t seglen = std::min(space, len - pos);
            seg = last_unsent;
            /* Create a PacketBuffer with a copy or reference to seglen bytes. We
                  * can use PBUF_RAW here since the data appears in the middle of
                  * a segment. A header will never be prepended. */
            if (apiflags & TCP_WRITE_FLAG_COPY)
            {
                /* Data is copied */
                if ((concat_p = tcp_pbuf_prealloc(seglen,
                                                  space,
                                                  &oversize,
                                                  pcb,
                                                  apiflags,
                                                  1)) == nullptr)
                {
                    Logf(true,
                         "tcp_write : could not allocate memory for PacketBuffer copy size %d\n"
                             , seglen);
                    goto memerr;
                }
                TCP_DATA_COPY2(concat_p->payload,
                               static_cast<uint8_t*>((uint8_t*)arg + pos),
                               seglen,
                               &concat_chksum,
                               &concat_chksum_swapped);
                concat_chksummed += seglen;
                // queuelen += pbuf_clen(concat_p);
            }
            else
            {
                /* Data is not copied */
                /* If the last unsent PacketBuffer is of type PBUF_ROM, try to extend it. */
                struct PacketBuffer* p;
                for (p = last_unsent->p; p->next != nullptr; p = p->next)
                {
                    ;
                }
                // if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS |
                //         0)) == 0) && (const uint8_t *)p->payload +
                //     p->
                //     len == (const uint8_t *)arg)
                // {
                //     lwip_assert("tcp_write: ROM pbufs cannot be oversized", pos == 0);
                //     extendlen = seglen;
                // }
                // else
                // {
                //     concat_p = PacketBuffer();
                //     // if ((concat_p = pbuf_alloc()) == nullptr)
                //     // {
                //     //     Logf(true | LWIP_DBG_LEVEL_SERIOUS,
                //     //          ("tcp_write: could not allocate memory for zero-copy PacketBuffer\n"
                //     //          ));
                //     //     goto memerr;
                //     // } /* reference the non-volatile payload data */
                //     // ((struct pbuf_rom *)concat_p)->payload = (const uint8_t *)arg + pos;
                //     // queuelen += pbuf_clen(concat_p);
                // } /* calculate the checksum of nocopy-data */
                tcp_seg_add_chksum(~inet_chksum((const uint8_t *)arg + pos, seglen),
                                   seglen,
                                   &concat_chksum,
                                   &concat_chksum_swapped);
                concat_chksummed += seglen;
            }
            pos += seglen;
        }
    }
    else
    {
        lwip_assert("unsent_oversize mismatch (pcb->unsent is NULL)",
                    pcb->unsent_oversize == 0);
    } /*
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
    while (pos < len)
    {
        struct PacketBuffer p{};
        uint16_t left = len - pos;
        uint16_t max_len = mss_local - optlen;
        uint16_t seglen = std::min(left, max_len);
        uint16_t chksum = 0;
        uint8_t chksum_swapped = 0;
        if (apiflags & TCP_WRITE_FLAG_COPY)
        {
            /* If copy is set, memory should be allocated and data copied
             * into PacketBuffer */
            if ((p = tcp_pbuf_prealloc(seglen + optlen,
                                       mss_local,
                                       &oversize,
                                       pcb,
                                       apiflags,
                                       queue == nullptr)) == nullptr)
            {
                Logf(true | LWIP_DBG_LEVEL_SERIOUS,
                     "tcp_write : could not allocate memory for PacketBuffer copy size %d\n"
                         , seglen);
                goto memerr;
            }
            lwip_assert(
                "tcp_write: check that first PacketBuffer can hold the complete seglen",
                (p->len >= seglen));
            TCP_DATA_COPY2(p->payload + optlen,
                           (uint8_t *)arg + pos,
                           seglen,
                           &chksum,
                           &chksum_swapped);
        }
        else
        {
            /* Copy is not set: First allocate a PacketBuffer for holding the data.
             * Since the referenced data is available at least until it is
             * sent out on the link (as it has to be ACKed by the remote
             * party) we can safely use PBUF_ROM instead of PBUF_REF here.
             */
            // struct PacketBuffer* p2;
            PacketBuffer p2{};
            lwip_assert("oversize == 0", oversize == 0);
            // if ((p2 = pbuf_alloc()) == nullptr)
            // {
            //     Logf(true | LWIP_DBG_LEVEL_SERIOUS,
            //          ("tcp_write: could not allocate memory for zero-copy PacketBuffer\n"
            //          ));
            //     goto memerr;
            // } /* calculate the checksum of nocopy-data */
            chksum = ~inet_chksum((const uint8_t *)arg + pos, seglen);
            if (seglen & 1)
            {
                chksum_swapped = 1;
                chksum = SWAP_BYTES_IN_WORD(chksum);
            } /* reference the non-volatile payload data */
            // ((struct pbuf_rom *)p2)->payload = (const uint8_t *)arg + pos;
            /* Second, allocate a PacketBuffer for the headers. */
            p = PacketBuffer();
            // if ((p = pbuf_alloc()) == nullptr)
            // {
            //     /* If allocation fails, we have to deallocate the data PacketBuffer as
            //      * well. */
            //     free_pkt_buf(p2);
            //     Logf(true,
            //          ("tcp_write: could not allocate memory for header PacketBuffer\n"));
            //     goto memerr;
            // } /* Concatenate the headers and data pbufs together. */
            // pbuf_cat(p/*header*/, p2/*data*/);
        }
        // queuelen += pbuf_clen(p);
        /* Now that there are more segments queued, we check again if the
            * length of the queue exceeds the configured maximum or
            * overflows. */
        if (queuelen > std::min(TCP_SND_QUEUELEN, 1))
        {
            Logf(true,
                 "tcp_write: queue too long %d (%d)\n", queuelen, (int)TCP_SND_QUEUELEN
                 );
            free_pkt_buf(p);
            goto memerr;
        }
        if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == nullptr
        )
        {
            goto memerr;
        }
        seg->chksum = chksum;
        seg->chksum_swapped = chksum_swapped;
        seg->flags |= TF_SEG_DATA_CHECKSUMMED; /* first segment of to-be-queued data? */
        if (queue == nullptr)
        {
            queue = seg;
        }
        else
        {
            /* Attach the segment to the end of the queued segments */
            lwip_assert("prev_seg != NULL", prev_seg != nullptr);
            prev_seg->next = seg;
        } /* remember last segment of to-be-queued data for next iteration */
        prev_seg = seg;
        Logf(true | LWIP_DBG_TRACE,
             "tcp_write: queueing %d:%d\n", lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(
                 seg->tcphdr->seqno) + tcp_tcplen(seg));
        pos += seglen;
    } /*
   * All three segmentation phases were successful. We can commit the
   * transaction.
   */ /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the PacketBuffer chain.
   */
    if (oversize_used > 0)
    {
        /* Bump tot_len of whole chain, len of tail */
        for (struct PacketBuffer* p = last_unsent->p; p; p = p->next)
        {
            p->tot_len += oversize_used;
            if (p->next == nullptr)
            {
                TCP_DATA_COPY(p->payload + p->len,
                              (uint8_t*)arg,
                              oversize_used,
                              last_unsent);
                p->len += oversize_used;
            }
        }
        last_unsent->len += oversize_used;
    }
    pcb->unsent_oversize = oversize; /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p, unless we
   * determined that the last ROM PacketBuffer can be extended to include the new data.
   */
    if (concat_p != nullptr)
    {
        lwip_assert("tcp_write: cannot concatenate when pcb->unsent is empty",
                    (last_unsent != nullptr));
        // pbuf_cat(last_unsent->p, concat_p);
        last_unsent->len += concat_p->tot_len;
    }
    else if (extendlen > 0)
    {
        struct PacketBuffer* p;
        lwip_assert("tcp_write: extension of reference requires reference",
                    last_unsent != nullptr && last_unsent->p != nullptr);
        for (p = last_unsent->p; p->next != nullptr; p = p->next)
        {
            p->tot_len += extendlen;
        }
        p->tot_len += extendlen;
        p->len += extendlen;
        last_unsent->len += extendlen;
    }
    if (concat_chksummed)
    {
        lwip_assert("tcp_write: concat checksum needs concatenated data",
                    concat_p != nullptr || extendlen > 0);
        /*if concat checksumm swapped - swap it back */
        if (concat_chksum_swapped)
        {
            concat_chksum = SWAP_BYTES_IN_WORD(concat_chksum);
        }
        tcp_seg_add_chksum(concat_chksum,
                           concat_chksummed,
                           &last_unsent->chksum,
                           &last_unsent->chksum_swapped);
        last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
    } /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
    if (last_unsent == nullptr)
    {
        pcb->unsent = queue;
    }
    else
    {
        last_unsent->next = queue;
    } /*
   * Finally update the pcb state.
   */
    pcb->snd_lbb += len;
    pcb->snd_buf -= len;
    pcb->snd_queuelen = queuelen;
    Logf(true, "tcp_write: %d (after enqueued)\n", pcb->snd_queuelen);
    if (pcb->snd_queuelen != 0)
    {
        lwip_assert("tcp_write: valid queue length",
                    pcb->unacked != nullptr || pcb->unsent != nullptr);
    } /* Set the PSH flag in the last segment that we enqueued. */
    if (seg != nullptr && seg->tcphdr != nullptr && ((apiflags & TCP_WRITE_FLAG_MORE) == 0
    ))
    {
        TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
    }
    return STATUS_OK;
memerr: tcp_set_flags(pcb, TF_NAGLEMEMERR);
    if (concat_p != nullptr)
    {
        free_pkt_buf(concat_p);
    }
    if (queue != nullptr)
    {
        tcp_segs_free(queue);
    }
    if (pcb->snd_queuelen != 0)
    {
        lwip_assert("tcp_write: valid queue length",
                    pcb->unacked != nullptr || pcb->unsent != nullptr);
    }
    Logf(true | LWIP_DBG_STATE,
         "tcp_write: %d (with mem err)\n", pcb->snd_queuelen);
    return ERR_MEM;
}

/**
 * Split segment on the head of the unsent queue.  If return is not
 * ERR_OK, existing head remains intact
 *
 * The split is accomplished by creating a new TCP segment and PacketBuffer
 * which holds the remainder payload after the split.  The original
 * PacketBuffer is trimmed to new length.  This allows splitting of read-only
 * pbufs
 *
 * @param pcb the TcpProtoCtrlBlk for which to split the unsent head
 * @param split the amount of payload to remain in the head
 */
LwipStatus
tcp_split_unsent_seg(struct TcpPcb *pcb, uint16_t split)
{
  struct TcpSeg *seg = nullptr, *useg = nullptr;
  struct PacketBuffer p{};
  uint16_t chksum = 0;
  uint8_t chksum_swapped = 0;
  lwip_assert("tcp_split_unsent_seg: invalid pcb", pcb != nullptr);

  useg = pcb->unsent;
  if (useg == nullptr) {
    return ERR_MEM;
  }

  if (split == 0) {
    lwip_assert("Can't split segment into length 0", false);
    return ERR_VAL;
  }

  if (useg->len <= split) {
    return STATUS_OK;
  }

  lwip_assert("split <= mss", split <= pcb->mss);
  lwip_assert("useg->len > 0", useg->len > 0);

  /* We should check that we don't exceed TCP_SND_QUEUELEN but we need
   * to split this packet so we may actually exceed the max value by
   * one!
   */
  Logf(true, "tcp_enqueue: split_unsent_seg: %u\n", pcb->snd_queuelen);

  uint8_t optflags = useg->flags;

  /* Remove since checksum is not stored until after tcp_create_segment() */
  optflags &= ~TF_SEG_DATA_CHECKSUMMED;
  const uint8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
  const uint16_t remainder = useg->len - split;

  /* Create new PacketBuffer for the remainder of the split */
  // p = pbuf_alloc();
    p = PacketBuffer();
  if (p == nullptr) {
    Logf(true,
         "tcp_split_unsent_seg: could not allocate memory for PacketBuffer remainder %u\n", remainder);
    goto memerr;
  }

  /* Offset into the original PacketBuffer is past TCP/IP headers, options, and split amount */
  uint16_t offset = useg->p->tot_len - useg->len + split;
  /* Copy remainder into new PacketBuffer, headers and options will not be filled out */
  if (pbuf_copy_partial(useg->p, (uint8_t *)p->payload + optlen, remainder, offset ) != remainder) {
    Logf(true,
         "tcp_split_unsent_seg: could not copy PacketBuffer remainder %u\n", remainder);
    goto memerr;
  }

  /* calculate the checksum on remainder data */
  tcp_seg_add_chksum(~inet_chksum((const uint8_t *)p->payload + optlen, remainder), remainder,
                     &chksum, &chksum_swapped);


  /* Options are created when calling tcp_output() */

  /* Migrate flags from original segment */
  uint8_t split_flags = tcph_flags(useg->tcphdr);
  uint8_t remainder_flags = 0; /* ACK added in tcp_output() */

  if (split_flags & TCP_PSH) {
    split_flags &= ~TCP_PSH;
    remainder_flags |= TCP_PSH;
  }
  if (split_flags & TCP_FIN) {
    split_flags &= ~TCP_FIN;
    remainder_flags |= TCP_FIN;
  }
  /* SYN should be left on split, RST should not be present with data */

  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
  if (seg == nullptr) {
    Logf(true | LWIP_DBG_LEVEL_SERIOUS,
         ("tcp_split_unsent_seg: could not create new TCP segment\n"));
    goto memerr;
  }

  seg->chksum = chksum;
  seg->chksum_swapped = chksum_swapped;
  seg->flags |= TF_SEG_DATA_CHECKSUMMED;

  /* Remove this segment from the queue since trimming it may free pbufs */
  // pcb->snd_queuelen -= pbuf_clen(useg->p);

  /* Trim the original PacketBuffer into our split size.  At this point our remainder segment must be setup
  successfully because we are modifying the original segment */
  // pbuf_realloc(useg->p);
  useg->len -= remainder;
  TCPH_SET_FLAG(useg->tcphdr, split_flags);

  /* By trimming, realloc may have actually shrunk the PacketBuffer, so clear oversize_left */
  // useg->oversize_left = 0;

  /* Add back to the queue with new trimmed PacketBuffer */
  // pcb->snd_queuelen += pbuf_clen(useg->p);

  /* The checksum on the split segment is now incorrect. We need to re-run it over the split */
  useg->chksum = 0;
  useg->chksum_swapped = 0;
  struct PacketBuffer* q = useg->p;
  offset = q->tot_len - useg->len; /* Offset due to exposed headers */

  /* Advance to the PacketBuffer where the offset ends */
  while (q != nullptr && offset > q->len) {
    offset -= q->len;
    q = q->next;
  }
  lwip_assert("Found start of payload PacketBuffer", q != nullptr);
  /* Checksum the first payload PacketBuffer accounting for offset, then other pbufs are all payload */
  for (; q != nullptr; offset = 0, q = q->next) {
    tcp_seg_add_chksum(~inet_chksum((const uint8_t *)q->payload + offset, q->len - offset), q->len - offset,
                       &useg->chksum, &useg->chksum_swapped);
  }


  /* Update number of segments on the queues. Note that length now may
   * exceed TCP_SND_QUEUELEN! We don't have to touch pcb->snd_buf
   * because the total amount of data is constant when packet is split */
  // pcb->snd_queuelen += pbuf_clen(seg->p);

  /* Finally insert remainder into queue after split (which stays head) */
  seg->next = useg->next;
  useg->next = seg;

  /* If remainder is last segment on the unsent, ensure we clear the oversize amount
   * because the remainder is always sized to the exact remaining amount */
  if (seg->next == nullptr) {
    pcb->unsent_oversize = 0;
  }


  return STATUS_OK;
memerr:

  lwip_assert("seg == NULL", seg == nullptr);
  if (p != nullptr) {
    free_pkt_buf(p);
  }

  return ERR_MEM;
}

/**
 * Called by tcp_close() to send a segment including FIN flag but not data.
 * This FIN may be added to an existing segment or a new, otherwise empty
 * segment is enqueued.
 *
 * @param pcb the TcpProtoCtrlBlk over which to send a segment
 * @return ERR_OK if sent, another LwipStatus otherwise
 */
LwipStatus
tcp_send_fin(struct TcpPcb *pcb)
{
  lwip_assert("tcp_send_fin: invalid pcb", pcb != nullptr);

  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != nullptr) {
    struct TcpSeg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != nullptr;
         last_unsent = last_unsent->next)
    {
        ;
    }
    if ((tcph_flags(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
      tcp_set_flags(pcb, TF_FIN);
      return STATUS_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
}

/**
 * Enqueue SYN or FIN for transmission.
 *
 * Called by @ref tcp_connect, tcp_listen_input, and @ref tcp_close
 * (via @ref tcp_send_fin)
 *
 * @param pcb Protocol control block for the TCP connection.
 * @param flags TCP header flags to set in the outgoing segment.
 */
LwipStatus
tcp_enqueue_flags(struct TcpPcb *pcb, uint8_t flags)
{
  struct PacketBuffer p{};
  struct TcpSeg *seg;
  uint8_t optflags = 0;
  uint8_t optlen = 0;

  Logf(true, "tcp_enqueue_flags: queuelen: %d\n", (uint16_t)pcb->snd_queuelen);

  lwip_assert("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);
  lwip_assert("tcp_enqueue_flags: invalid pcb", pcb != nullptr);

  /* No need to check pcb->snd_queuelen if only SYN or FIN are allowed! */

  /* Get options for this segment. This is a special case since this is the
     only place where a SYN can be sent. */
  if (flags & TCP_SYN) {
    optflags = TF_SEG_OPTS_MSS;

    if ((pcb->state != SYN_RCVD) || (pcb->flags & TF_WND_SCALE)) {
      /* In a <SYN,ACK> (sent in state SYN_RCVD), the window scale option may only
         be sent if we received a window scale option from the remote host. */
      optflags |= TF_SEG_OPTS_WND_SCALE;
    }

    if ((pcb->state != SYN_RCVD) || (pcb->flags & TF_SACK)) {
      /* In a <SYN,ACK> (sent in state SYN_RCVD), the SACK_PERM option may only
         be sent if we received a SACK_PERM option from the remote host. */
      optflags |= TF_SEG_OPTS_SACK_PERM;
    }

  }

  if ((pcb->flags & TF_TIMESTAMP) || ((flags & TCP_SYN) && (pcb->state != SYN_RCVD))) {
    /* Make sure the timestamp option is only included in data segments if we
       agreed about it with the remote host (and in active open SYN segments). */
    optflags |= TF_SEG_OPTS_TS;
  }

  // optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);

  /* Allocate PacketBuffer with room for TCP header + options */
    p = PacketBuffer();
  // if ((p = pbuf_alloc()) == nullptr) {
  //   tcp_set_flags(pcb, TF_NAGLEMEMERR);
  //   return ERR_MEM;
  // }
  lwip_assert("tcp_enqueue_flags: check that first PacketBuffer can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == nullptr) {
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
    return ERR_MEM;
  }
  lwip_assert("seg->tcphdr not aligned", ((uintptr_t)seg->tcphdr % std::min(1, 4)) == 0);
  lwip_assert("tcp_enqueue_flags: invalid segment length", seg->len == 0);

  Logf(true | LWIP_DBG_TRACE,
       "tcp_enqueue_flags: queueing %d:%d (0x%x)\n",
           lwip_ntohl(seg->tcphdr->seqno),
           lwip_ntohl(seg->tcphdr->seqno) + tcp_tcplen(seg),
           (uint16_t)flags);

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == nullptr) {
    pcb->unsent = seg;
  } else {
    struct TcpSeg *useg;
    for (useg = pcb->unsent; useg->next != nullptr; useg = useg->next)
    {
        ;
    }
    useg->next = seg;
  }

  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;


  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
    /* optlen does not influence snd_buf */
  }
  if (flags & TCP_FIN) {
    tcp_set_flags(pcb, TF_FIN);
  }

  /* update number of segments on the queues */
  // pcb->snd_queuelen += pbuf_clen(seg->p);
  Logf(true, "tcp_enqueue_flags: %d (after enqueued)\n", pcb->snd_queuelen);
  if (pcb->snd_queuelen != 0) {
    lwip_assert("tcp_enqueue_flags: invalid queue length",
                pcb->unacked != nullptr || pcb->unsent != nullptr);
  }

  return STATUS_OK;
}

/* Build a timestamp option (12 bytes long) at the specified options pointer)
 *
 * @param pcb TcpProtoCtrlBlk
 * @param opts option pointer where to store the timestamp option
 */
static void
tcp_build_timestamp_option(const struct TcpPcb *pcb, uint32_t *opts)
{
  lwip_assert("tcp_build_timestamp_option: invalid pcb", pcb != nullptr);

  /* Pad with two NOP options to make everything nicely aligned */
  opts[0] = pp_htonl(0x0101080A);
  opts[1] = lwip_htonl(sys_now());
  opts[2] = lwip_htonl(pcb->ts_recent);
}

/**
 * Calculates the number of SACK entries that should be generated.
 * It takes into account whether TF_SACK flag is set,
 * the number of SACK entries in TcpProtoCtrlBlk that are valid,
 * as well as the available options size.
 *
 * @param pcb TcpProtoCtrlBlk
 * @param optlen the length of other TCP options (in bytes)
 * @return the number of SACK ranges that can be used
 */
static uint8_t
tcp_get_num_sacks(const struct TcpPcb* pcb, uint8_t optlen)
{
    uint8_t num_sacks = 0;
    lwip_assert("tcp_get_num_sacks: invalid pcb", pcb != nullptr);
    if (pcb->flags & TF_SACK)
    {
        /* The first SACK takes up 12 bytes (it includes SACK header and two NOP options),
         each additional one - 8 bytes. */
        optlen += 12;
        /* Max options size = 40, number of SACK array entries = LWIP_TCP_MAX_SACK_NUM */
        for (uint8_t i = 0; (i < LWIP_TCP_MAX_SACK_NUM) && (optlen <= 0xff) &&
             tcp_sack_valid(pcb, i); ++i)
        {
            ++num_sacks;
            optlen += 8;
        }
    }
    return num_sacks;
}

/** Build a SACK option (12 or more bytes long) at the specified options pointer)
 *
 * @param pcb TcpProtoCtrlBlk
 * @param opts option pointer where to store the SACK option
 * @param num_sacks the number of SACKs to store
 */
static void
tcp_build_sack_option(const struct TcpPcb *pcb, uint32_t *opts, uint8_t num_sacks)
{
    lwip_assert("tcp_build_sack_option: invalid pcb", pcb != nullptr);
  lwip_assert("tcp_build_sack_option: invalid opts", opts != nullptr);

  /* Pad with two NOP options to make everything nicely aligned.
     We add the length (of just the SACK option, not the NOPs in front of it),
     which is 2B of header, plus 8B for each SACK. */
  *(opts++) = pp_htonl(0x01010500 + 2 + num_sacks * 8);

  for (uint8_t i = 0; i < num_sacks; ++i) {
    *(opts++) = lwip_htonl(pcb->rcv_sacks[i].left);
    *(opts++) = lwip_htonl(pcb->rcv_sacks[i].right);
  }
}

/** Build a window scale option (3 bytes long) at the specified options pointer)
 *
 * @param opts option pointer where to store the window scale option
 */
static void
tcp_build_wnd_scale_option(uint32_t *opts)
{
  lwip_assert("tcp_build_wnd_scale_option: invalid opts", opts != nullptr);

  /* Pad with one NOP option to make everything nicely aligned */
  opts[0] = pp_htonl(0x01030300 | 0xff);
}

/**
 * @ingroup tcp_raw
 * Find out what we can send and send it
 *
 * @param pcb Protocol control block for the TCP connection to send data
 * @return ERR_OK if data has been sent or nothing to send
 *         another LwipStatus on error
 */
LwipStatus
tcp_output(struct TcpPcb *pcb)
{
    lwip_assert("tcp_output: invalid pcb", pcb != nullptr);
  /* pcb->state LISTEN not allowed here */
  lwip_assert("don't call tcp_output for listen-pcbs",
              pcb->state != LISTEN);

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return STATUS_OK;
  }

  uint32_t wnd = std::min(pcb->snd_wnd, pcb->cwnd);

  struct TcpSeg* seg = pcb->unsent;

  if (seg == nullptr) {
    Logf(true, "tcp_output: nothing to send (%p)\n",
             (uint8_t *)pcb->unsent);
    // Logf(true, ("tcp_output: snd_wnd %d, cwnd %d, wnd %d, seg == NULL, ack %d\n",
    //          pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));

    /* If the TF_ACK_NOW flag is set and the ->unsent queue is empty, construct
     * an empty ACK segment and send it. */
    if (pcb->flags & TF_ACK_NOW) {
      return tcp_send_empty_ack(pcb);
    }
    /* nothing to send: shortcut out of here */
    goto output_done;
  } else {
    // Logf(true,
    //      ("tcp_output: snd_wnd %d, cwnd %d, wnd %d, effwnd %d, seq %d, ack %d\n",
    //          pcb->snd_wnd, pcb->cwnd, wnd,
    //          lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
    //          lwip_ntohl(seg->tcphdr->seqno), pcb->lastack));
  }

  NetworkInterface* netif = tcp_route(pcb, &pcb->local_ip, &pcb->remote_ip);
  if (netif == nullptr) {
    return STATUS_E_ROUTING;
  }

  /* If we don't have a local IP address, we get one from netif */
  if (is_ip_addr_any(&pcb->local_ip)) {
    const IpAddrInfo *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
    if (local_ip == nullptr) {
      return STATUS_E_ROUTING;
    }
    copy_ip_addr(&pcb->local_ip, local_ip);
  }

  /* Handle the current segment not fitting within the window */
  if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
    /* We need to start the persistent timer when the next unsent segment does not fit
     * within the remaining (could be 0) send window and RTO timer is not running (we
     * have no in-flight data). If window is still too small after persist timer fires,
     * then we split the segment. We don't consider the congestion window since a cwnd
     * smaller than 1 SMSS implies in-flight data
     */
    if (wnd == pcb->snd_wnd && pcb->unacked == nullptr && pcb->persist_backoff == 0) {
      pcb->persist_cnt = 0;
      pcb->persist_backoff = 1;
      pcb->persist_probe = 0;
    }
    /* We need an ACK, but can't send data now, so send an empty ACK */
    if (pcb->flags & TF_ACK_NOW) {
      return tcp_send_empty_ack(pcb);
    }
    goto output_done;
  }
  /* Stop persist timer, above conditions are not active */
  pcb->persist_backoff = 0;

  /* useg should point to last segment on unacked queue */
  struct TcpSeg* useg = pcb->unacked;
  if (useg != nullptr) {
    for (; useg->next != nullptr; useg = useg->next)
    {
        ;
    }
  }
  /* data available and window allows it to be sent? */
  while (seg != nullptr &&
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    lwip_assert("RST not expected here!",
                (tcph_flags(seg->tcphdr) & TCP_RST) == 0);
    /* Stop sending if the nagle algorithm would prevent it
     * Don't stop:
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if ((tcp_do_output_nagle(pcb) == 0) &&
        ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
      break;
    }


    if (pcb->state != SYN_SENT) {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    }

    LwipStatus err = tcp_output_segment(seg, pcb, netif);
    if (err != STATUS_OK) {
      /* segment could not be sent, for whatever reason */
      tcp_set_flags(pcb, TF_NAGLEMEMERR);
      return err;
    }

    pcb->unsent = seg->next;
    if (pcb->state != SYN_SENT) {
      tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
    }
    uint32_t snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + tcp_tcplen(seg);
    if (tcp_seq_lt(pcb->snd_nxt, snd_nxt)) {
      pcb->snd_nxt = snd_nxt;
    }
    /* put segment on unacknowledged list if length > 0 */
    if (tcp_tcplen(seg) > 0) {
      seg->next = nullptr;
      /* unacked list is empty? */
      if (pcb->unacked == nullptr) {
        pcb->unacked = seg;
        useg = seg;
        /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (tcp_seq_lt(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct TcpSeg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
                 tcp_seq_lt(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
            cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
          (*cur_seg) = seg;
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
          useg = useg->next;
        }
      }
      /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (pcb->unsent == nullptr) {
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }


output_done:
  tcp_clear_flags(pcb, TF_NAGLEMEMERR);
  return STATUS_OK;
}

/** Check if a segment's pbufs are used by someone else than TCP.
 * This can happen on retransmission if the PacketBuffer of this segment is still
 * referenced by the netif driver due to deferred transmission.
 * This is the case (only!) if someone down the TX call path called
 * pbuf_ref() on one of the pbufs!
 *
 * @arg seg the tcp segment to check
 * @return 1 if ref != 1, 0 if ref == 1
 */
static int
tcp_output_segment_busy(const struct TcpSeg *seg)
{
  lwip_assert("tcp_output_segment_busy: invalid seg", seg != nullptr);

  /* We only need to check the first PacketBuffer here:
     If a PacketBuffer is queued for transmission, a driver calls pbuf_ref(),
     which only changes the ref count of the first PacketBuffer */
  // if (seg->p->ref_count != 1) {
  //   /* other reference found */
  //   return 1;
  // }
  /* no other references found */
  return 0;
}

/**
 * Called by tcp_output() to actually send a TCP segment over IP.
 *
 * @param seg the tcp_seg to send
 * @param pcb the TcpProtoCtrlBlk for the TCP connection used to send the segment
 * @param netif the netif used to send the segment
 */
static LwipStatus
tcp_output_segment(struct TcpSeg *seg, struct TcpPcb *pcb, NetworkInterface*netif)
{
    int seg_chksum_was_swapped = 0;


  lwip_assert("tcp_output_segment: invalid seg", seg != nullptr);
  lwip_assert("tcp_output_segment: invalid pcb", pcb != nullptr);
  lwip_assert("tcp_output_segment: invalid netif", netif != nullptr);

  if (tcp_output_segment_busy(seg)) {
    /* This should not happen: rexmit functions should have checked this.
       However, since this function modifies p->len, we must not continue in this case. */
    Logf(true | LWIP_DBG_LEVEL_SERIOUS, ("tcp_output_segment: segment busy\n"));
    return STATUS_OK;
  }

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);

  /* advertise our receive window size in this TCP segment */

  if (seg->flags & TF_SEG_OPTS_WND_SCALE) {
    /* The Window field in a SYN segment itself (the only type where we send
       the window scale option) is never scaled. */
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
  } else

  {
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
  }

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  /* cast through void* to get rid of alignment warnings */
  uint32_t* opts = (uint32_t *)(uint8_t *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
      uint16_t mss = tcp_eff_send_mss_netif(TCP_MSS, netif, &pcb->remote_ip);

    *opts = TCP_BUILD_MSS_OPTION(mss);
    opts += 1;
  }

  pcb->ts_lastacksent = pcb->rcv_nxt;

  if (seg->flags & TF_SEG_OPTS_TS) {
    tcp_build_timestamp_option(pcb, opts);
    opts += 3;
  }


  if (seg->flags & TF_SEG_OPTS_WND_SCALE) {
    tcp_build_wnd_scale_option(opts);
    opts += 1;
  }


  if (seg->flags & TF_SEG_OPTS_SACK_PERM) {
    /* Pad with two NOP options to make everything nicely aligned
     * NOTE: When we send both timestamp and SACK_PERM options,
     * we could use the first two NOPs before the timestamp to store SACK_PERM option,
     * but that would complicate the code.
     */
    *(opts++) = pp_htonl(0x01010402);
  }


  /* Set retransmission timer running if it is not currently enabled
     This must be set before checking the route. */
  if (pcb->rtime < 0) {
    pcb->rtime = 0;
  }

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);

    Logf(true, "tcp_output_segment: rtseq %d\n", pcb->rtseq);
  }
  Logf(true, "tcp_output_segment: %d:%d\n",
           lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
           seg->len);

  uint16_t len = (uint16_t)((uint8_t *)seg->tcphdr - (uint8_t *)seg->p->payload);
  if (len == 0) {
    /** Exclude retransmitted segments from this count. */

  }

  seg->p->len -= len;
  seg->p->tot_len -= len;

  seg->p->payload = (uint8_t*)seg->tcphdr;

  seg->tcphdr->chksum = 0;

  // opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(seg->p, seg->tcphdr, pcb, opts);

  // lwip_assert("options not filled", (uint8_t *)opts == ((uint8_t *)(seg->tcphdr + 1)) + LWIP_TCP_OPT_LENGTH_SEGMENT(seg->flags, pcb));


 if( is_netif_checksum_enabled(netif, NETIF_CHECKSUM_GEN_TCP)) {
        uint16_t chksum_slow = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
                                                seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);

    if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
      lwip_assert("data included but not checksummed",
                  seg->p->tot_len == get_tcp_hdr_len(seg->tcphdr));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    uint32_t acc = ip_chksum_pseudo_partial(seg->p,
                                            IP_PROTO_TCP,
                                            seg->p->tot_len,
                                            get_tcp_hdr_len(seg->tcphdr),
                                            &pcb->local_ip,
                                            &pcb->remote_ip);
    /* add payload checksum */
    if (seg->chksum_swapped) {
      seg_chksum_was_swapped = 1;
      seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
      seg->chksum_swapped = 0;
    }
    acc = (uint16_t)~acc + seg->chksum;
    seg->tcphdr->chksum = (uint16_t)~fold_u32(acc);

    if (chksum_slow != seg->tcphdr->chksum) {
      // TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL(
      //   ("tcp_output_segment: calculated checksum is %x instead of %x\n",
      //    seg->tcphdr->chksum, chksum_slow));
      seg->tcphdr->chksum = chksum_slow;
    }

  }

  // TCP_STATS_INC(tcp.xmit);

  netif_set_hints(netif, pcb->netif_hints);
    const LwipStatus err = ip_output_if(seg->p,
                                &pcb->local_ip,
                                &pcb->remote_ip,
                                pcb->ttl,
                                pcb->tos,
                                IP_PROTO_TCP,
                                netif);
  netif_reset_hints(netif);


  if (seg_chksum_was_swapped) {
    /* if data is added to this segment later, chksum needs to be swapped,
       so restore this now */
    seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
    seg->chksum_swapped = 1;
  }

  return err;
}

/**
 * Requeue all unacked segments for retransmission
 *
 * Called by tcp_slowtmr() for slow retransmission.
 *
 * @param pcb the TcpProtoCtrlBlk for which to re-enqueue all unacked segments
 */
LwipStatus
tcp_rexmit_rto_prepare(struct TcpPcb *pcb)
{
  struct TcpSeg *seg;

  lwip_assert("tcp_rexmit_rto_prepare: invalid pcb", pcb != nullptr);

  if (pcb->unacked == nullptr) {
    return ERR_VAL;
  }

  /* Move all unacked segments to the head of the unsent queue.
     However, give up if any of the unsent pbufs are still referenced by the
     netif driver due to deferred transmission. No point loading the link further
     if it is struggling to flush its buffered writes. */
  for (seg = pcb->unacked; seg->next != nullptr; seg = seg->next) {
    if (tcp_output_segment_busy(seg)) {
      Logf(true, ("tcp_rexmit_rto: segment busy\n"));
      return ERR_VAL;
    }
  }
  if (tcp_output_segment_busy(seg)) {
    Logf(true, ("tcp_rexmit_rto: segment busy\n"));
    return ERR_VAL;
  }
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;

  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  /* unacked queue is now empty */
  pcb->unacked = nullptr;

  /* Mark RTO in-progress */
  tcp_set_flags(pcb, TF_RTO);
  /* Record the next byte following retransmit */
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + tcp_tcplen(seg);
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  return STATUS_OK;
}

/**
 * Requeue all unacked segments for retransmission
 *
 * Called by tcp_slowtmr() for slow retransmission.
 *
 * @param pcb the TcpProtoCtrlBlk for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto_commit(struct TcpPcb *pcb)
{
  lwip_assert("tcp_rexmit_rto_commit: invalid pcb", pcb != nullptr);

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
    ++pcb->nrtx;
  }
  /* Do the actual retransmission */
  tcp_output(pcb);
}

/**
 * Requeue all unacked segments for retransmission
 *
 * Called by tcp_process() only, tcp_slowtmr() needs to do some things between
 * "prepare" and "commit".
 *
 * @param pcb the TcpProtoCtrlBlk for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct TcpPcb *pcb)
{
  lwip_assert("tcp_rexmit_rto: invalid pcb", pcb != nullptr);

  if (tcp_rexmit_rto_prepare(pcb) == STATUS_OK) {
    tcp_rexmit_rto_commit(pcb);
  }
}

/**
 * Requeue the first unacked segment for retransmission
 *
 * Called by tcp_receive() for fast retransmit.
 *
 * @param pcb the TcpProtoCtrlBlk for which to retransmit the first unacked segment
 */
LwipStatus
tcp_rexmit(struct TcpPcb *pcb)
{
    lwip_assert("tcp_rexmit: invalid pcb", pcb != nullptr);

  if (pcb->unacked == nullptr) {
    return ERR_VAL;
  }

  struct TcpSeg* seg = pcb->unacked;

  /* Give up if the segment is still referenced by the netif driver
     due to deferred transmission. */
  if (tcp_output_segment_busy(seg)) {
    Logf(true, ("tcp_rexmit busy\n"));
    return ERR_VAL;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  pcb->unacked = seg->next;

  struct TcpSeg** cur_seg = &(pcb->unsent);
  while (*cur_seg &&
         tcp_seq_lt(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
    cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
  *cur_seg = seg;

  if (seg->next == nullptr) {
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }


  if (pcb->nrtx < 0xFF) {
    ++pcb->nrtx;
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission. */

  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
  return STATUS_OK;
}


/**
 * Handle retransmission after three dupacks received
 *
 * @param pcb the TcpProtoCtrlBlk for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct TcpPcb *pcb)
{
  lwip_assert("tcp_rexmit_fast: invalid pcb", pcb != nullptr);

  if (pcb->unacked != nullptr && !(pcb->flags & TF_INFR)) {
    /* This is fast retransmit. Retransmit the first unacked segment. */
    Logf(true,
         "tcp_receive: dupacks %d (%d), fast retransmit %d\n",
             (uint16_t)pcb->dupacks, pcb->lastack,
             lwip_ntohl(pcb->unacked->tcphdr->seqno));
    if (tcp_rexmit(pcb) == STATUS_OK) {
      /* Set ssthresh to half of the minimum of the current
       * cwnd and the advertised window */
      pcb->ssthresh = std::min(pcb->cwnd, pcb->snd_wnd) / 2;

      /* The minimum value for ssthresh should be 2 MSS */
      if (pcb->ssthresh < (2U * pcb->mss)) {
        Logf(true,
             "tcp_receive: The minimum value for ssthresh %d should be min 2 mss %d...\n",
                 pcb->ssthresh, (uint16_t)(2 * pcb->mss));
        pcb->ssthresh = 2 * pcb->mss;
      }

      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
      tcp_set_flags(pcb, TF_INFR);

      /* Reset the retransmission timer to prevent immediate rto retransmissions */
      pcb->rtime = 0;
    }
  }
}

static struct PacketBuffer *
tcp_output_alloc_header_common(uint32_t ackno, uint16_t optlen, uint16_t datalen,
                        uint32_t seqno_be /* already in network byte order */,
                        uint16_t src_port, uint16_t dst_port, uint8_t flags, uint16_t wnd)
{
    // struct PacketBuffer* p = pbuf_alloc();
    PacketBuffer p{};
  if (p != nullptr) {
    lwip_assert("check that first pbuf can hold TcpHdr",
                (p->len >= TCP_HDR_LEN + optlen));
    struct TcpHdr* tcphdr = (struct TcpHdr *)p->payload;
    tcphdr->src = lwip_htons(src_port);
    tcphdr->dest = lwip_htons(dst_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = lwip_htonl(ackno);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), flags);
    tcphdr->wnd = lwip_htons(wnd);
    tcphdr->chksum = 0;
    tcphdr->urgp = 0;
  }
  return p;
}

/** Allocate a PacketBuffer and create a tcphdr at p->payload, used for output
 * functions other than the default tcp_output -> tcp_output_segment
 * (e.g. tcp_send_empty_ack, etc.)
 *
 * @param pcb tcp pcb for which to send a packet (used to initialize tcp_hdr)
 * @param optlen length of header-options
 * @param datalen length of tcp data to reserve in PacketBuffer
 * @param seqno_be seqno in network byte order (big-endian)
 * @return PacketBuffer with p->payload being the tcp_hdr
 */
static struct PacketBuffer *
tcp_output_alloc_header(struct TcpPcb *pcb, uint16_t optlen, uint16_t datalen,
                        uint32_t seqno_be /* already in network byte order */)
{
    lwip_assert("tcp_output_alloc_header: invalid pcb", pcb != nullptr);

  struct PacketBuffer* p = tcp_output_alloc_header_common(
      pcb->rcv_nxt,
      optlen,
      datalen,
      seqno_be,
      pcb->local_port,
      pcb->remote_port,
      TCP_ACK,
      TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
  if (p != nullptr) {
    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
  }
  return p;
}

/* Fill in options for control segments */
static void
tcp_output_fill_options(const struct TcpPcb *pcb, struct PacketBuffer *p, uint8_t optflags, uint8_t num_sacks)
{
    uint16_t sacks_len = 0;

  lwip_assert("tcp_output_fill_options: invalid pbuf", p != nullptr);

  struct TcpHdr* tcphdr = (struct TcpHdr *)p->payload;
  uint32_t* opts = (uint32_t *)(uint8_t *)(tcphdr + 1);

  /* NB. MSS and window scale options are only sent on SYNs, so ignore them here */


  if (optflags & TF_SEG_OPTS_TS) {
    tcp_build_timestamp_option(pcb, opts);
    opts += 3;
  }



  if (pcb && (num_sacks > 0)) {
    tcp_build_sack_option(pcb, opts, num_sacks);
    /* 1 word for SACKs header (including 2xNOP), and 2 words for each SACK */
    sacks_len = 1 + num_sacks * 2;
    opts += sacks_len;
  }


  // opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(p, tcphdr, pcb, opts);
  //   lwip_assert("options not filled", (uint8_t *)opts == ((uint8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb));
}

/** Output a control segment PacketBuffer to IP.
 *
 * Called from tcp_rst, tcp_send_empty_ack, tcp_keepalive and tcp_zero_window_probe,
 * this function combines selecting a netif for transmission, generating the tcp
 * header checksum and calling ip_output_if while handling netif hints and stats.
 */
static LwipStatus
tcp_output_control_segment(const struct TcpPcb *pcb, struct PacketBuffer *p,
                           const IpAddrInfo *src, const IpAddrInfo *dst)
{
  LwipStatus err;
  lwip_assert("tcp_output_control_segment: invalid pbuf", p != nullptr);

  NetworkInterface* netif = tcp_route(pcb, src, dst);
  if (netif == nullptr) {
    err = STATUS_E_ROUTING;
  } else {
    uint8_t ttl, tos;

   if( is_netif_checksum_enabled(netif, NETIF_CHECKSUM_GEN_TCP)) {
      struct TcpHdr *tcphdr = (struct TcpHdr *)p->payload;
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
                                        src, dst);
    }

    if (pcb != nullptr) {
      netif_set_hints(netif,  pcb->netif_hints);
      ttl = pcb->ttl;
      tos = pcb->tos;
    } else {
      /* Send output with hardcoded TTL/HL since we have no access to the pcb */
      ttl = TCP_TTL;
      tos = 0;
    }
    // TCP_STATS_INC(tcp.xmit);
    err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
    netif_reset_hints(netif);
  }
  free_pkt_buf(p);
  return err;
}

/**
 * Send a TCP RESET packet (empty segment with RST flag set) either to
 * abort a connection or to show that there is no matching local connection
 * for a received segment.
 *
 * Called by tcp_abort() (to abort a local connection), tcp_input() (if no
 * matching local pcb was found), tcp_listen_input() (if incoming segment
 * has ACK flag set) and tcp_process() (received segment in the wrong state)
 *
 * Since a RST segment is in most cases not sent for an active connection,
 * tcp_rst() has a number of arguments that are taken from a TcpProtoCtrlBlk for
 * most other segment output functions.
 *
 * @param pcb TCP pcb (may be NULL if no pcb is available)
 * @param seqno the sequence number to use for the outgoing segment
 * @param ackno the acknowledge number to use for the outgoing segment
 * @param local_ip the local IP address to send the segment from
 * @param remote_ip the remote IP address to send the segment to
 * @param local_port the local TCP port to send the segment from
 * @param remote_port the remote TCP port to send the segment to
 */
void
tcp_rst(const struct TcpPcb *pcb, uint32_t seqno, uint32_t ackno,
        const IpAddrInfo *local_ip, const IpAddrInfo *remote_ip,
        uint16_t local_port, uint16_t remote_port)
{
    lwip_assert("tcp_rst: invalid local_ip", local_ip != nullptr);
  lwip_assert("tcp_rst: invalid remote_ip", remote_ip != nullptr);

  // uint8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);

  size_t optlen = 0;
  uint16_t wnd = pp_htons(((TCP_WND >> 0xff) & 0xFFFF));


  struct PacketBuffer* p = tcp_output_alloc_header_common(
      ackno,
      optlen,
      0,
      lwip_htonl(seqno),
      local_port,
      remote_port,
      TCP_RST | TCP_ACK,
      wnd);
  if (p == nullptr) {
    Logf(true, ("tcp_rst: could not allocate memory for PacketBuffer\n"));
    return;
  }
  tcp_output_fill_options(pcb, p, 0, optlen);



  tcp_output_control_segment(pcb, p, local_ip, remote_ip);
  Logf(true, "tcp_rst: seqno %d ackno %d.\n", seqno, ackno);
}

/**
 * Send an ACK without data.
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
LwipStatus
tcp_send_empty_ack(struct TcpPcb *pcb)
{
    uint8_t optflags = 0;
  uint8_t num_sacks = 0;

  lwip_assert("tcp_send_empty_ack: invalid pcb", pcb != nullptr);

  if (pcb->flags & TF_TIMESTAMP) {
    optflags = TF_SEG_OPTS_TS;
  }

  // uint8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
    size_t optlen = 0;

  /* For now, SACKs are only sent with empty ACKs */
  if ((num_sacks = tcp_get_num_sacks(pcb, optlen)) > 0) {
    optlen += 4 + num_sacks * 8; /* 4 bytes for header (including 2*NOP), plus 8B for each SACK */
  }


  struct PacketBuffer* p = tcp_output_alloc_header(pcb,
                                                   optlen,
                                                   0,
                                                   lwip_htonl(pcb->snd_nxt));
  if (p == nullptr) {
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
    Logf(true, ("tcp_output: (ACK) could not allocate PacketBuffer\n"));
    return ERR_BUF;
  }
  tcp_output_fill_options(pcb, p, optflags, num_sacks);


  pcb->ts_lastacksent = pcb->rcv_nxt;


  Logf(true,
       "tcp_output: sending ACK for %d\n", pcb->rcv_nxt);
  LwipStatus err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
  if (err != STATUS_OK) {
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
  } else {
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
  }

  return err;
}

/**
 * Send keepalive packets to keep a connection active although
 * no data is sent over it.
 *
 * Called by tcp_slowtmr()
 *
 * @param pcb the TcpProtoCtrlBlk for which to send a keepalive packet
 */
LwipStatus
tcp_keepalive(struct TcpPcb *pcb)
{
    // uint8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
        size_t optlen = 0;

  lwip_assert("tcp_keepalive: invalid pcb", pcb != nullptr);

  Logf(true, ("tcp_keepalive: sending KEEPALIVE probe to "));
  // ip_addr_debug_print_val(true, pcb->remote_ip);
  Logf(true, ("\n"));

  Logf(true, "tcp_keepalive: tcp_ticks %d   pcb->tmr %d pcb->keep_cnt_sent %d\n",
           tcp_ticks, pcb->tmr, (uint16_t)pcb->keep_cnt_sent);

  struct PacketBuffer* p = tcp_output_alloc_header(pcb,
                                                   optlen,
                                                   0,
                                                   lwip_htonl(pcb->snd_nxt - 1));
  if (p == nullptr) {
    Logf(true,
         ("tcp_keepalive: could not allocate memory for PacketBuffer\n"));
    return ERR_MEM;
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
  LwipStatus err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);

  Logf(true,"tcp_keepalive: seqno %d ackno %d err %d.\n",
           pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err);
  return err;
}

/**
 * Send persist timer zero-window probes to keep a connection active
 * when a window update is lost.
 *
 * Called by tcp_slowtmr()
 *
 * @param pcb the TcpProtoCtrlBlk for which to send a zero-window probe packet
 */
LwipStatus
tcp_zero_window_probe(struct TcpPcb* pcb)
{
    // uint8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
    const size_t optlen = 0;
    lwip_assert("tcp_zero_window_probe: invalid pcb", pcb != nullptr);
    Logf(true, ("tcp_zero_window_probe: sending ZERO WINDOW probe to "));
    // ip_addr_debug_print_val(true, pcb->remote_ip);
    Logf(true, ("\n"));
    Logf(true,
         "tcp_zero_window_probe: tcp_ticks %d   pcb->tmr %d pcb->keep_cnt_sent %d\n",
         tcp_ticks,
         pcb->tmr,
         uint16_t(pcb->keep_cnt_sent));
    /* Only consider unsent, persist timer should be off when there is data in-flight */
    struct TcpSeg* seg = pcb->unsent;
    if (seg == nullptr)
    {
        /* Not expected, persist timer should be off when the send buffer is empty */
        return STATUS_OK;
    } /* increment probe count. NOTE: we record probe even if it fails
     to actually transmit due to an error. This ensures memory exhaustion/
     routing problem doesn't leave a zero-window pcb as an indefinite zombie.
     RTO mechanism has similar behavior, see pcb->nrtx */
    if (pcb->persist_probe < 0xFF)
    {
        ++pcb->persist_probe;
    }
    uint8_t is_fin = ((tcph_flags(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    /* we want to send one seqno: either FIN or data (no options) */
    uint16_t len = is_fin ? 0 : 1;
    struct PacketBuffer* p =
        tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
    if (p == nullptr)
    {
        Logf(true, ("tcp_zero_window_probe: no memory for PacketBuffer\n"));
        return ERR_MEM;
    }
    struct TcpHdr* tcphdr = (struct TcpHdr *)p->payload;
    if (is_fin)
    {
        /* FIN segment, no data */
        TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
    }
    else
    {
        /* Data segment, copy in one byte from the head of the unacked queue */
        uint8_t* d = p->payload + TCP_HDR_LEN;
        /* Depending on whether the segment has already been sent (unacked) or not
              (unsent), seg->p->payload points to the IP header or TCP header.
              Ensure we copy the first TCP data byte: */
        pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
    } /* The byte may be acknowledged without the window being opened. */
    uint32_t snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
    if (tcp_seq_lt(pcb->snd_nxt, snd_nxt))
    {
        pcb->snd_nxt = snd_nxt;
    }
    tcp_output_fill_options(pcb, p, 0, optlen);
    LwipStatus err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
    Logf(true,
         "tcp_zero_window_probe: seqno %d ackno %d err %d.\n",
         pcb->snd_nxt - 1,
         pcb->rcv_nxt,
         (int)err);
    return err;
}

